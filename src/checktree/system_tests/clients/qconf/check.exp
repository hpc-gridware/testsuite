#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
#  Portions of this software are Copyright (c) 2023-2024 HPC-Gridware GmbH
#
##########################################################################
#___INFO__MARK_END__

# Define the global variables to give them back
global check_name
global check_description
global check_needs
global check_functions
global check_root_access_needs
global ts_config
global check_category

set check_root_access_needs "yes"

# define test's name and run level descriptions
set check_name            "qconf"
set check_category        "RQS VERIFIED"
set check_description(0)  "test all qconf options (test not complete)"

# define test's dependencies
set check_needs        "init_core_system"       ;# dependencies of this check (name of other check)


global qconf_original_host_groups qconf_original_usersets
# setup and cleanup functions
set check_setup_function "qconf_setup"
set check_cleanup_function "qconf_cleanup"

# define test's procedure order
set check_functions     ""
lappend check_functions "qconf_addqueues"             ;# functions to call (in order)
lappend check_functions "qconf_removequeues"
lappend check_functions "qconf_auser"
lappend check_functions "qconf_duser"
lappend check_functions "qconf_Auser"
lappend check_functions "qconf_muser"
lappend check_functions "qconf_Muser"
lappend check_functions "qconf_segfault"
lappend check_functions "qconf_se"
lappend check_functions "qconf_sel"

# TODO: the aattr/rattr checks are broken or not fully
# ported to 6.0
#lappend check_functions "qconf_aattr_check"
#lappend check_functions "qconf_rattr_check"
#lappend check_functions "qconf_Aattr_check"


# Show options DONE
lappend check_functions "qconf_scal_check"   ;# List calendars
lappend check_functions "qconf_scall_check"	 ;# List all calalendars
lappend check_functions "qconf_sconfl_check" ;# List all hosts with configurations
lappend check_functions "qconf_sds_check"	 ;# List detached settings in the cluster  config
lappend check_functions "qconf_secl_check" 	 ;# List event client list
lappend check_functions "qconf_sep_check"	 ;# List processors
lappend check_functions "qconf_sm_check"	 ;# List  managers
lappend check_functions "qconf_so_check"	 ;# List operators
lappend check_functions "qconf_ss_check"	 ;# List submit hosts
lappend check_functions "qconf_sss_check"	 ;# Show scheduler status
lappend check_functions "qconf_sul_check"	 ;# Show user list
lappend check_functions "qconf_sprjl_check"	 ;# Show project list

# New options, non-show DONE
lappend check_functions "qconf_add_delete_manager" 	            ;# Add and delete manager users
lappend check_functions "qconf_add_show_mod_del_queue" 	        ;# Add, show, modify and delete queue "qconf_queue.q"
lappend check_functions "qconf_add_show_delete_stnode"          ;# Add, show and delete share tree nodes
lappend check_functions "qconf_create_modify_sharetree"         ;# create and modify a sharetree (qconf -Mstree)
lappend check_functions "qconf_del_sharetree"                   ;# delete the whole sharetree (qconf -dstree)
lappend check_functions "qconf_event_client"                    ;# Create, show and delete event clients
lappend check_functions "qconf_add_delete_modify_calendar"	    ;# Add, delete and modify calendar
lappend check_functions "qconf_add_delete_modify_replace_attr"  ;# Add, delete and modify attributes
lappend check_functions "qconf_modify_checkpoint"               ;# Create, modify and delete checkpoint
lappend check_functions "qconf_add_project"                     ;# qconf -aprj / qconf -Aprj
lappend check_functions "qconf_modify_exechost"	                ;# Modify exec host
lappend check_functions "qconf_modify_project"                  ;# Modify project
lappend check_functions "qconf_modify_userlist"                 ;# Modify user list
lappend check_functions "qconf_modify_sched_conf"               ;# Modify scheduler config
lappend check_functions "qconf_issue_2023"
lappend check_functions "qconf_brief_exercise" ;# check the output messages

lappend check_functions "qconf_de_check"
lappend check_functions "qconf_backslash_default_space_check"  ;# functions to call (in order)
lappend check_functions "qconf_backslash_default_comma_check"
lappend check_functions "qconf_backslash_custom_space_check"
lappend check_functions "qconf_backslash_custom_comma_check"
lappend check_functions "qconf_backslash_space_output_check"
lappend check_functions "qconf_backslash_comma_output_check"

lappend check_functions "qconf_issue1767"
lappend check_functions "qconf_shgrp_tree_check"	    ;# List tree like structure of hosts
lappend check_functions "qconf_shgrp_resolved_check"	;# List  hosts in a group
lappend check_functions "qconf_modify_hostgroup"

lappend check_functions "qconf_purge_queue"
lappend check_functions "qconf_add_rqs"                 ;# add resource quota set
lappend check_functions "qconf_modify_rqs"              ;# modify resource quota set
lappend check_functions "qconf_modifyreplace_rqs"       ;# modify/replace resource quota set
lappend check_functions "qconf_remove_rqs"              ;# delete resource quota set
lappend check_functions "qconf_dynamic_limit"           ;# add a dynamic limit
lappend check_functions "qconf_rqs_Xattr"               ;# resource quota set Xattr
lappend check_functions "qconf_rqs_rattr_qmaster_dump"  ;# verify error handling
lappend check_functions "qconf_issue_2383"              ;# TS case for IZ 2383
lappend check_functions "qconf_issue_2445"              ;# TS case for IZ 2445
lappend check_functions "qconf_help"                    ;# TS case for qconf [-help] return values
lappend check_functions "qconf_Aconf"                   ;# TS case for qconf -Aconf with already existing configuration
lappend check_functions "qconf_delete_admin_user"       ;# deleting manager or operator must fail for root and admin user
lappend check_functions "qconf_ke"	                    ;# TS case for qconf -ke with already shutdown daemon

lappend check_functions "qconf_issue_2960"

proc qconf_setup {} {
   global ts_config CHECK_USER
   global qconf_original_host_groups qconf_original_usersets qconf_orig_queues qconf_project qconf_sched_config qconf_userlist
   global backup_allhosts
   global queue_names
   global qconf_setup_complex_backup

   if {[llength $ts_config(execd_nodes)] < 2} {
      ts_log_config "need at least 2 execd hosts for this check"
      return 99
   }

   get_complex qconf_setup_complex_backup

   set queue_names ""
   set MAX 1000
   for {set i 0} {$i < $MAX}  {incr i 1} {
      lappend queue_names "q.$i"
   }

   # host group setup for GE >= 6.0
   # we'll create additional host groups later on - remember the list of hostgroups
   # for cleanup
   set output [start_sge_bin qconf -shgrpl]
   set output [string trim $output]
   set qconf_original_host_groups {}
   foreach hg $output {
      ts_log_fine "saving known hostgroup \"$hg\" for cleanup procedure"
      lappend qconf_original_host_groups $hg
   }

   # create a test hostgroup
   set qconf_hgrp_setup(group_name) "@qconf_test"
   set qconf_hgrp_setup(hostlist)   "$ts_config(execd_nodes)"
   add_hostgroup "@qconf_test" qconf_hgrp_setup

   get_userset_list output
   set output [string trim $output]
   set qconf_original_usersets {}
   foreach user $output {
      lappend qconf_original_usersets $user
      ts_log_fine "saving known userset \"$output\" for cleanup procedure"
   }

   # Save initial queue list; make it a global var, to be used in cleanup
   get_queue_list qconf_orig_queues

   set qconf_project "qconf_project"
   ts_log_fine "Create project $qconf_project ...\n"
   set result [add_project $qconf_project]

   ts_log_fine "Create userlist qconf_userlist ...\n"
   add_access_list $CHECK_USER qconf_userlist

   ts_log_fine "Save existing scheduler config ...\n"
   get_schedd_config qconf_sched_config
}

proc qconf_cleanup {} {
   global ts_config
   global qconf_original_host_groups qconf_original_usersets qconf_orig_queues qconf_sched_config
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER qconf_prj_setup
   global qconf_setup_complex_backup

   ts_log_fine "cleanup ..."

   # in GE >= 6.0: cleanup hostgroups
   set output [start_sge_bin qconf -shgrpl]
   set output [string trim $output]
   foreach hg $output {
      ts_log_fine "testing hostgroup \"$hg\" ..."
      if {[lsearch -exact $qconf_original_host_groups $hg] < 0} {
         ts_log_fine "deleting unexpected hostgroup \"$hg\" ..."
         del_hostgroup $hg
      }
   }

   ts_log_fine "Delete userlist qconf_userlist ...\n"
   set result [start_sge_bin "qconf" "-dul qconf_userlist" "" ""]

   set output [start_sge_bin qconf -sul]
   set output [string trim $output]
   foreach userg $output {
      ts_log_fine "testing userset \"$userg\" ..."
      if { [lsearch -exact $qconf_original_usersets $userg] < 0 } {
         ts_log_fine "deleting unexpected usergroup \"$userg\" ..."
         set res [start_sge_bin qconf "-dul $userg"]
         ts_log_fine $res
      }
   }

   # The original stuff is here
   delete_all_jobs
   wait_for_end_of_all_jobs 60

   # Delete stuff I created
   del_manager "qconf_user" "" "" 0

   # Get list of new queues. Those created during the
   # tests will be deleted here.

   get_queue_list qconf_new_queues

   ts_log_fine "Deleting queues created during qconf..."
   foreach elem  $qconf_orig_queues {
      foreach new_elem $qconf_new_queues {
         if { $elem == $new_elem } {
            continue
         } else {
	         del_queue $new_elem ""
         }
      }
   }

   # Re-set it back
   set my_project "qconf_project"
   ts_log_fine "Delete project $my_project ..."
   set result [del_project $my_project "" "" 0]

   # Set sched back to what it was....
   ts_log_fine "Set scheduler to original config ..."
   set result [mod_schedd_config qconf_sched_config]

   # Re-set resource quota sets
   if {[get_rqs_list rqs_names "" "" 0] == 0} {
      foreach elem $rqs_names {
         ts_log_fine "Removing resource quota sets $elem ...\n"
         del_rqs $elem
      }
   }

   reset_complex qconf_setup_complex_backup
   unset qconf_setup_complex_backup

   # sometimes exec hosts "stuff" and "universalNOTVALIDvalue" are left over
   start_sge_bin "qconf" "-de stuff"
   start_sge_bin "qconf" "-de universalNOTVALIDvalue"
}

proc qconf_auser {} {
   global CHECK_PRODUCT_TYPE CHECK_USER
   global ts_config

   ts_log_fine "testing qconf -auser ..."

   if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0} {
      set test_user "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user "$test_user" new_user
      set output [start_sge_bin "qconf" "-suser $test_user"]
      if {[string first "mytestproject" $output] < 0} {
         ts_log_severe "error showing user $test_user"
      }
   }
}

proc qconf_duser {} {
   global CHECK_PRODUCT_TYPE CHECK_USER
   global ts_config

   ts_log_fine "testing qconf -duser ..."

   if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0} {
      del_user "qconf_test_user"

      set output [start_sge_bin "qconf" "-suser qconf_test_user"]
      if {[string first "mytestproject" $output] >= 0} {
         ts_log_severe "error user qconf_test_user should have been deleted"
      }
   }
}


proc qconf_Auser {} {
   global CHECK_PRODUCT_TYPE CHECK_USER
   global ts_config

   ts_log_fine "testing qconf -Auser ..."

   if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0} {
      set test_user "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user "$test_user" new_user 1
      set output [start_sge_bin "qconf" "-suser $test_user"]
      if {[string first "mytestproject" $output] < 0} {
         ts_log_severe "error showing user $test_user"
      }
      del_user "$test_user"
   }
}


proc qconf_muser {} {
   global CHECK_PRODUCT_TYPE CHECK_USER
   global ts_config

   ts_log_fine "testing qconf -muser ..."

   if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0} {
      set test_user "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user "$test_user" new_user
      set output [start_sge_bin "qconf" "-suser $test_user"]
      if { [string first "mytestproject" $output] < 0  } {
         ts_log_severe "error showing user $test_user"
      }
      # now modify user
      set new_conf(default_project) "NONE"
      mod_user $test_user new_conf 
      set output [start_sge_bin "qconf" "-suser $test_user"]
      ts_log_fine $output
      if {[string first "mytestproject" $output] >= 0} {
         ts_log_severe "error modify user $test_user"
      }

      # now delete user
      del_user $test_user
   }
}

proc qconf_Muser {} {
   global CHECK_PRODUCT_TYPE CHECK_USER
   global ts_config

   ts_log_fine "testing qconf -Muser ..."

   if {[string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0} {
      set test_user "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user "$test_user" new_user
      set output [start_sge_bin "qconf" "-suser $test_user"]
      if { [string first "mytestproject" $output] < 0  } {
         ts_log_severe "error showing user $test_user"
      }
      # now modifiy user
      set new_conf(default_project) "NONE"
      mod_user "$test_user" new_conf 1
      set output [start_sge_bin "qconf" "-suser $test_user"]
      ts_log_fine $output
      if {[string first "mytestproject" $output] >= 0} {
         ts_log_severe "error modify user $test_user"
      }

      # now delete user
      del_user "$test_user"
   }
}

proc qconf_addqueues {} {
   global ts_config
   global queue_names test_host

   set q_param(load_thresholds)       "np_load_avg=7.00"

   set test_host [host_conf_get_suited_hosts]

   set count 0
   foreach queue $queue_names {
      if { $count > 50 } {
         ts_log_fine "adding queue \"$queue\" with vi"
         add_queue $queue $test_host q_param 0
         set count 0
      } else {
         ts_log_fine "adding queue \"$queue\" with file"
         add_queue $queue $test_host q_param
      }
      incr count 1
   }
}

proc qconf_removequeues {} {
   global ts_config
   global queue_names test_host

   foreach queue $queue_names {
     ts_log_fine "deleting queue \"$queue\""
     del_queue $queue $test_host 0 1
   }
}

proc check_exec_conf { host_list attr_name check_value } {

  foreach host $host_list {
     get_exechost host_config $host
     set host_attr_value $host_config($attr_name)

     ts_log_fine "host \"$host\": $attr_name is set to \"$host_attr_value\"" 

     if { [ string compare $check_value $host_attr_value ] != 0 } {
        ts_log_fine "\"$check_value\" is not \"$host_attr_value\""
        ts_log_severe "\"$check_value\" is not \"$host_attr_value\"" 
     }
  } 
}

# check all queues in queue_list for attr_name and compare it with check_value
proc check_queue_conf { queue_list attr_name check_value } {
  foreach queue $queue_list {
     get_queue $queue q_config
     set q_attr_value $q_config($attr_name)

     ts_log_fine "queue \"$queue\": $attr_name is set to \"$q_attr_value\"" 

     if { [ string compare $check_value $q_attr_value ] != 0 } {
        ts_log_fine "\"$check_value\" is not \"$q_attr_value\""
        ts_log_severe "\"$check_value\" is not \"$q_attr_value\"" 
     }
  } 
}

proc qconf_aattr_check {} {
   global ts_config
   global queue_names

   # check queue add normal attribute
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"
   ts_log_fine "adding qtype PARALLEL to queues $queue_names"
   set output [start_sge_bin "qconf" "-aattr queue qtype PARALLEL $queue_names"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE PARALLEL"

    
   # check queue add parameter list
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"
   ts_log_fine "adding qtype PARALLEL to queues $queue_names"
   set output [start_sge_bin "qconf" "-aattr queue load_thresholds \"mem_free=1M\" $queue_names"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00,mem_free=1M"

   # check global host add user_lists list
   check_exec_conf $ts_config(execd_nodes) user_lists "NONE"

   ts_log_fine "adding deadlineusers to user_lists of all execd hosts"
   set output [start_sge_bin "qconf" "-aattr exechost user_lists \"deadlineusers\" $ts_config(execd_nodes)"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_exec_conf $ts_config(execd_nodes) user_lists "deadlineusers"

   ts_log_fine "adding defaultdepartment to user_lists of all execd hosts"
   set output [start_sge_bin "qconf" "-aattr exechost user_lists \"defaultdepartment\" $ts_config(execd_nodes)"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_exec_conf $ts_config(execd_nodes) user_lists "deadlineusers defaultdepartment"
}

proc qconf_Aattr_check {} {
   global ts_config queue_names 
   global CHECK_ACTUAL_TEST_PATH

   # check queue add normal attribute
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"

   ts_log_fine "adding qtype PARALLEL and load_thresholds mem_free=1M to queues $queue_names"
   set output [start_sge_bin "qconf" "-Aattr queue $CHECK_ACTUAL_TEST_PATH/Aattr_file_queue_wrong_syntax  $queue_names"]
   if {$prg_exit_state != 1} {
      ts_log_severe "exit state is not 1 (used wrong file syntax format)"
   }
   set output [start_sge_bin "qconf" "-Aattr queue $CHECK_ACTUAL_TEST_PATH/Aattr_file_queue $queue_names"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE PARALLEL"
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00,mem_free=1M"
}

proc qconf_rattr_check {} {
   global ts_config
   global queue_names

   ts_log_fine "replaceing exechost user_lists with NONE"
   set output [start_sge_bin "qconf" "-rattr exechost user_lists \"NONE\" $ts_config(execd_nodes)"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output

   check_exec_conf $ts_config(execd_nodes) user_lists "NONE"

   ts_log_fine "replaceing queues qtype with BATCH INTERACTIVE"
   set output [start_sge_bin "qconf" "-rattr queue qtype \"BATCH INTERACTIVE\" $queue_names"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"

   ts_log_fine "replaceing queues load_thresholds with np_load_avg=7.00"
   set output [start_sge_bin "qconf" "-rattr queue load_thresholds \"np_load_avg=7.00\" $queue_names"]
   if {$prg_exit_state != 0} {
     ts_log_severe "exit state is not 0"
   }          
   ts_log_fine $output
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"
}

proc qconf_segfault {} {
   global ts_config CHECK_USER

   set output [start_sge_bin "qconf" "-as \"\""]
   if { [string match "*egmentation ?ault*" $output] == 1 } {
      ts_log_fine $output
      ts_log_severe "qconf -as \"\" failed - see Issue: 1732"
   }
   set output [start_sge_bin "qconf" "-ah \"\""]

   if { [string match "*egmentation ?ault*" $output] == 1 } {
      ts_log_fine $output
      ts_log_severe "qconf -ah \"\" failed - see Issue: 1732"
   }

   set output [start_sge_bin "qconf" "-ae localhost"]

   if { [string match "*egmentation ?ault*" $output] == 1 } {
      ts_log_fine $output
      ts_log_severe "qconf -ah \"\" failed - see Issue: 1884"
   } else {
      set output [start_sge_bin "qconf" "-de localhost"]
   }
}

proc qconf_se {} {
   global ts_config
  
   # test hosts
   set cluster_host [host_conf_get_suited_hosts]
   set non_cluster_host [host_conf_get_non_cluster_host]

   # fields delivered by qconf -se
   set qconf_se_fields "hostname load_scaling complex_values load_values processors user_lists xuser_lists projects xprojects usage_scaling report_variables"

   # positive check
   # check qconf -se <an exec host>, check completeness of result
   if {[get_exechost exec_host $cluster_host] == 0} {
      foreach elem $qconf_se_fields {
         if {![info exists exec_host($elem)]} {
            ts_log_severe "$elem is missing in result of qconf -se"
         }
      }
   }

   # negative checks
   # check qconf -se <a non exec host>
   if {$non_cluster_host != ""} {
      if {[get_exechost exec_host $non_cluster_host "" "" 0] == 0} {
         ts_log_severe "qconf -se $non_cluster_host (non cluster host) should have failed"
      }
   }

   # check qconf -se from a non admin/submit host
   if {$non_cluster_host != ""} {
      set result [get_exechost exec_host $cluster_host $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $result "any"]} {
         ts_log_info "qconf -se called on $non_cluster_host (non submit/admin host) should have failed\nknown issue 1889 fixed for release >= 6.1"
      }
   }
}

proc qconf_sel {} {
   global ts_config
  
   # test hosts
   set non_cluster_host [host_conf_get_non_cluster_host]

   # positive check
   # qconf -sel, has to match testsuite's execd_nodes list
   if {[get_exechost_list exechost_list] == 0} {
      if {[host_list_compare $exechost_list $ts_config(execd_nodes) 1 1] != 0} {
         ts_log_severe "exec host list delivered by qconf does not match testsuite exec host list:\nexec host list: $exechost_list\ntestsuite execd host list: $ts_config(execd_nodes)"
      }
   }

   # negative check
   # call qconf -sel on a non admin/submit host
   if {$non_cluster_host != ""} {
      set result [get_exechost_list exechost_list $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $result "any"]} {
         ts_log_info "qconf -sel called on $non_cluster_host (non submit/admin host) should have failed\nknown issue 1889 fixed for release >= 6.1"
      }
   }
}


#                                                             max. column:     |
#****** qconf/qconf_scal_check() ******
#
#  NAME
#     qconf_scal_check - Check known calendar "always_suspend"
#
#  SYNOPSIS
#     qconf_scal_check { } - Call get_calendar with calendar "always_suspend"
#                            Then call get_calendar with a wrong calendar name,
#                            like "wrong_calendar". 
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_calendar/get_calendar()
# sge_calendar/get_calender_error()
#
#*******************************
proc qconf_scal_check {} {
   global ts_config env
   global CHECK_USER


   # First do a positive test, give a valid calendar name, "always_suspend"
   ts_log_fine "Positive test for qconf -scal always_suspend...\n"
   set result0 [get_calendar "always_suspend" ]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -scal always_suspend succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   # Next do a negative test, give a invalid calendar name, "wrong_calendar"
   ts_log_fine "Negative test for qconf -scal wrong_calendar...\n"
   set result1 [get_calendar "wrong_calendar" result $ts_config(master_host) $CHECK_USER 0 ]

   if { ( $result1 == -1 ) } {
      ts_log_fine "qconf -scal wrong_calendar succeded"
   } else {
      ts_log_fine "result is $result1"

   }
}

#                                                             max. column:     |
#****** qconf/qconf_scall_check() ******
#
#  NAME
#     qconf_scall_check - Check all known calendars 
#
#  SYNOPSIS
#     qconf_scall_check { } - Call get_calendar_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_calendar/get_calendar_list()
#*******************************
proc qconf_scall_check {} {

   global ts_config env
   global CHECK_USER

   # Do a positive test
   ts_log_fine "Positive test for qconf -scall ...\n"
   set result0 [get_calendar_list]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -scall succeded"
   } else {
      ts_log_fine "result is $result0"

   }
}

#                                                             max. column:     |
#****** qconf/qconf_sconfl_check() ******
#
#  NAME
#     qconf_sconfl_check - Display a list of hosts  for  which  configurations
#                          are  available.  
#
#  SYNOPSIS
#     qconf_sconfl_check { } - Call get_config_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_config_list()
#*******************************

proc qconf_sconfl_check {} {

   global ts_config env
   global CHECK_USER

   # Do a positive test
    ts_log_fine "Positive test for qconf -sconfl ...\n"

   set result0 [get_queue_config_list ]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sconfl succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_sds_check() ******
#
#  NAME
#     qconf_sds_check - Display detached settings in the cluster  config
#
#  SYNOPSIS
#     qconf_sds_check { } - Call get_detached_settings
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_procedures/get_detached_settings()
#*******************************

proc qconf_sds_check {} {

   global ts_config env queue_names
   global CHECK_USER 
  
   # First do a positive test
   ts_log_fine "1) Doing positive test!"

   set result0 [get_detached_settings]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sds succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   #Now check if the error code is set incase of error
   #for forcing the error we set the cq conf as:
   #qconf -sq tq | head -3
   # qname                 tq
   # hostlist              NONE
   # seq_no                0,[@allhosts=1]
   ts_log_fine "2) Doing exit code test in case of error!\n"

   set nohost "NONE" 

   # Just take the first queue name for testing!
   set queue [lindex $queue_names 0]
   set q_param(seq_no)	"0,\[@qconf_test=1\]"

   ts_log_fine "adding queue \"$queue\" with vi"
   add_queue $queue $nohost q_param 0

   #We know we are getting an error
   set result0 [get_detached_settings output "" "" 0]

   #Need to check if the error code is set to non-zero
   if { ( $result0 == 0 ) } {
      ts_log_severe "qconf -sds wrong exit code on error"
   } else {
      ts_log_fine "qconf -sds exit code on error - succeded\n$result0"
   }

   #clean up the queue
   del_queue $queue $nohost 0 1

}

#                                                      max. column:     |
#****** qconf/qconf_secl_check() ******
#
#  NAME
#     qconf_secl_check - Display the event client list
#
#  SYNOPSIS
#     qconf_secl_check { } - Call get_event_client_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_event_client/get_event_client_list()
#*******************************

proc qconf_secl_check {} {
   global ts_config env
   global CHECK_USER

   # Do a positive test
   ts_log_fine "Positive test for qconf -secl ...\n"

   set result0 [get_event_client_list]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -secl succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}

#                                               max. column:     | #
#****** qconf/qconf_sep_check() ******  
#  NAME
#     qconf_sep_check - Display the processor list
#
#  SYNOPSIS
#     qconf_sep_check { } - Call get_processor_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_processor_list()
#*******************************
proc qconf_sep_check {} {
   global ts_config env
   global CHECK_USER

   # DO A Positive test
   ts_log_fine "Positive test for qconf -sep ...\n"
   set result0 [get_processor_list]

  if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sep succeded\n"
   } else {
      ts_log_fine "result is $result0"
   }
}
#                                                             max. column:     |
#****** qconf/qconf_sm_check() ******
#
#  NAME
#     qconf_sm_check - Display list of managers
#
#  SYNOPSIS
#     qconf_sm_check { } - Call get_manager_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_manager_list()
#*******************************
proc qconf_sm_check {} {
   global ts_config env
   global CHECK_USER

   # First do a positive test
   ts_log_fine "Positive test for qconf -sm ...\n"

   set result0 [get_manager_list]

  if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sm succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}
#                                                             max. column:     |
#****** qconf/qconf_so_check() ******
#
#  NAME
#     qconf_so_check - Display list of operators
#
#  SYNOPSIS
#     qconf_so_check { } - Call get_operator_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_operator_list()
#*******************************
proc qconf_so_check {} {
   global ts_config env
   global CHECK_USER

   # Do a positive test
   ts_log_fine "Positive test for qconf -so ...\n"
   set result0 [get_operator_list]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -so succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_ss_check() ******
#
#  NAME
#     qconf_ss_check - Display list of submit hosts
#
#  SYNOPSIS
#     qconf_ss_check { } - Call get_submithost_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_submithost_list()
#*******************************
proc qconf_ss_check {} {
   global ts_config env
   global CHECK_USER

   # Do a positive test
   ts_log_fine "Positive test for qconf -ss ...\n"
   set result0 [get_submithost_list ]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -ss succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}
#                                                             max. column:     |
#****** qconf/qconf_sss_check() ******
#
#  NAME
#     qconf_sss_check - Display scheduler status
#
#  SYNOPSIS
#     qconf_sss_check { } - Call "qconf -sss "
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_procedures/get_scheduler_status()
#*******************************
proc qconf_sss_check {} {
   global ts_config env
   global CHECK_USER

   # Do a positive tests
   ts_log_fine "Positive test for qconf -sss ...\n"
   set result0 [get_scheduler_status]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sss succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}
#                                                             max. column:     |
#****** qconf/qconf_sul_check() ******
#
#  NAME
#     qconf_sul_check - Display user list
#
#  SYNOPSIS
#     qconf_sul_check { } - Call get_userset_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_users/get_userset_list()
#*******************************
proc qconf_sul_check {} {
   global ts_config env
   global CHECK_USER

   # Do q positive test
   ts_log_fine "Positive test for qconf -sul ...\n"
   set result0 [get_userset_list userset_list]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sul succeded"
   } else {
      ts_log_severe "qconf -sul failed"
      ts_log_fine "result is $result0"
   }
}
#                                                             max. column:     |
#****** qconf/qconf_sprjl_check() ******
#
#  NAME
#     qconf_sprjl_check - Display project list
#
#  SYNOPSIS
#     qconf_sprjl_check { } - Call "qconf -sprjl "
#                            Check that the output contains   "mytestproject"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_sprjl_check {} {
   global ts_config env
   global CHECK_USER

    # Do a positive test
    ts_log_fine "Positive test for qconf -sprjl ...\n"
    set result0 [get_project_list]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -sprjl succeded"
   } else {
      ts_log_fine "result is $result0"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_add_delete_manager() ******
#
#  NAME
#     qconf_add_delete_manager - Add and delete manager user
#
#  SYNOPSIS
#     qconf_add_delete_manager { } - Call add_manager, get_manager_list,
#	                             del_manager
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_users/add_manager()
# sge_users/get_manager_list()
# sge_users/del_manager()
#*******************************
proc qconf_add_delete_manager {} {
   global ts_config env
   global CHECK_USER

   # First add manager "qconf_user"
   ts_log_fine "Positive test for qconf -am ..."
   add_manager "qconf_user"

   # Now show manager list, check that  "qconf_user" is there
   ts_log_fine "Positive test for qconf -sm ..."
   get_manager_list

   # Now delete manager "qconf_user"
   ts_log_fine "Positive test for qconf -dm ..."
   del_manager "qconf_user"

   # Now delete manager "qconf_user" again
   # Don't run it with 6.0, here qconf will exit 0
   ts_log_fine "Negative test for qconf -dm ..."
   set result [del_manager "qconf_user" "" "" 0]
   if {$result == 0} {
      ts_log_severe "qconf -dm succeeded, but should have failed"
   }
}


#                                                             max. column:     |
#****** qconf/qconf_add_show_mod_del_queue() ******
#
#  NAME
#     qconf_add_show_mod_del_queue - Add, show modify and delete queue "qconf_queue.q"
#
#  SYNOPSIS
#     qconf_add_show_mod_del_queue { } - Call add_queue qconf_queue.q $ts_config(master_host) new_queue
#                                then   "qconf -sq qconf_queue.q" to show new queue
#                                Use "qconf -M(m)q queue qname qconf_queue.q"
#                                Also use "qconf -purge queue qname qconf_queue.q"
#                                Then clean up with "qconf -dq qconf_queue.q"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# sge_queue/add_queue()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_show_mod_del_queue {} {
   global ts_config env 
   global CHECK_USER 

   # First add queue "qconf_queue.q". Set the new name to "qconf_queue.q, 
   # host to $host

   set host [host_conf_get_suited_hosts]
   ts_log_fine "Adding queue qconf_queue.q ..."
   add_queue qconf_queue.q $host new_queue 

   #Now test for qconf -sq queue@host
   #qconf -sq q@host | grep complex_values should show NONE
   set qconf_qinst "qconf_queue.q@$host"
   ts_log_fine "Testing qconf -sq `$qconf_qinst'..."
   set result [start_sge_bin "qconf" "-sq $qconf_qinst"]
   if {$prg_exit_state != 0} {
      ts_log_severe "qconf -sq $qconf_qinst failed:\n$result"
      return
   }

   # split each line as listelement
   set op_rows [split $result "\n"]
 
   #test if the complex_values attrib has any value!
   foreach elem $op_rows {
       if {[string first "complex_values" $elem] >=0} {
          ts_log_fine "qconf -sq retured $elem"
 			if {[string last "NONE" $elem] >=0} {
 				ts_log_fine "qconf -sq queue@host successfull"
 			} else {
            ts_log_severe "qconf -sq queue@host should have output NONE for complex_values, but output was:\n$result"
 			}		
 			break
 		}
   }

   # Now do positive test on qconf -sql
   ts_log_fine "Positive test of qconf -sql ..."
   set result [get_queue_list queue_list]

   if {$result == 0} {
      ts_log_fine "qconf -sql succeded"
   } else {
      ts_log_fine "qconf -sql succeded" ;# error raised in get_queue_list
   }

   # Now modify queue qconf_queue.q
   set new_queue(seq_no)  "2"
   ts_log_fine "Modifying information for qconf_queue.q ..."
   set result [mod_queue "qconf_queue.q" "" new_queue]

   if {$result == 0} {
      ts_log_fine "qconf -Mq succeded"
   } else {
      ts_log_fine "result is $result" ;# error raised in mod_queue
   }
 
   # Now modify queue qconf_queue.q slow
   set new_queue(seq_no)  "1"
   ts_log_fine "Modifying information for qconf_queue.q slow..."
   set result [mod_queue "qconf_queue.q" "" new_queue 0]

   if {$result == 0} {
      ts_log_fine "qconf -mq succeded"
   } else {
      ts_log_fine "result is $result" ;# error raised in mod_queue
   }

   #  Now try to modify a invalid seq. no
   set new_queue(seq_no) "-1"
   ts_log_fine "Negative test of qconf -Mq qconf_queue.q, seq.  number..."
   set result [mod_queue "qconf_queue.q" "" new_queue 1  $host $CHECK_USER 0]

   if {$result < 0} {
      ts_log_fine "qconf -Mq wrong_project failed successfully"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1982
      ts_log_severe "mod_queue with invalid sequence number should have failed, but exit code (from handle_sge_errors) was $result"
   }
 
   # Now clear queue "qconf_queue.q"
   ts_log_fine "Clearing queue qconf_queue.q ... - "
   set result [clear_queue "qconf_queue.q" cq_output]

   if {$result == 0} {
      ts_log_fine "OK"
   } else {
      ts_log_fine "failed" ;# error raised in clear_queue
   }
   
   # Now try to clear it again!
   ts_log_fine "Clearing queue qconf_queue.q again... - "
   set result [clear_queue "qconf_queue.q" cq_output]

   if {$result == 0} {
      ts_log_fine "OK"
   } else {
      ts_log_fine "failed" ;# error raised in clear_queue
   }

   #  Now try to clear a non-existing queue, "wrong_queue.q"
   ts_log_fine "Negative test of qconf -cq wrong_queue.q ... - "
   set result [clear_queue "wrong_queue.q" cq_output $host $CHECK_USER 0]

   if {$result == -1} {
      ts_log_fine "OK"
   } else {
      ts_log_severe "clear_queue with non existing queue name should have failed, but exit code (from handle_sge_errors) was $result"
   }

   # Now delete queue "qconf_queue.q"
   ts_log_fine "Positive test of qconf -dq qconf_queue.q... -"
   set result [del_queue "qconf_queue.q" $host 1 1]

   if {$result == 0} {
      ts_log_fine "OK"
   } else {
      ts_log_fine "failed" ;# error raised in del_queue
   }
}
#                                                             max. column:     |
#****** qconf/qconf_add_show_delete_host() ******
#
#  NAME
#     qconf_add_show_delete_host - Add, show and delete host execd_nodes 1
#
#  SYNOPSIS
#     qconf_add_show_delete_host { } - Call "qconf -dh execd_host "
#	                         Show it with "qconf -sh"
#                                Then add it ack with "qconf -ah execd_host"
#                                Try to add it again
#                                Show it with "qconf -sh"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_show_delete_host {} {
   global ts_config env CHECK_ACTUAL_TEST_PATH
   global CHECK_USER 

   set hosts [host_conf_get_suited_hosts 2]
   set host       [lindex $hosts 0]
   set other_host [lindex $hosts 1]


   # First delete host $other_host. 
   ts_log_fine "Positive test of qconf -dh $other_host...\n"
   set result1 [del_adminhost $other_host]

   if { ( $result1 == 0 ) } {
      ts_log_fine "qconf -dh $other_host succeded"
   } else {
      ts_log_fine "result is $result1"
   }

   # Try deleting $other_host again
   ts_log_fine "Negative test of qconf -dh  $other_host...\n"
   set result4 [del_adminhost $other_host $host $CHECK_USER 0]

   if { ( $result4 == -1 ) } {
      ts_log_fine "qconf -dh $other_host again succeded"
   } else {
      ts_log_fine "result is $result4"
   }

   # Now show admin hosts 
   ts_log_fine "Positive test of qconf -sh  $other_host...\n"
   set result3 [get_adminhost_list]

   if { ( $result3 == 0 ) } {
      ts_log_fine "qconf -sh succeded"
   } else {
      ts_log_fine "result is $result3"
   }

  
 # Now add back $other_host
   ts_log_fine "Positive test of qconf -ah  $other_host...\n"
   set result5 [add_adminhost $other_host]

   if { ( $result5 == 0 ) } {
      ts_log_fine "qconf -ah $other_host succeded"
   } else {
      ts_log_fine "result is $result5"
   }

   # Now try adding it again
   ts_log_fine "Negative test of qconf -ah $other_host ...\n"

   set result6 [add_adminhost $other_host]

   if { ( $result6 == 0 ) } {
      ts_log_fine "qconf -ah $other_host again succeded"
   } else {
      ts_log_fine "result is $result6"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_add_show_delete_stnode() ******
#
#  NAME
#     qconf_add_show_delete_stnode - Add, show and delete sharetree
#
#  SYNOPSIS
#     qconf_add_show_delete_stnode { } - Call "qconf -astnode ..."
#                                Show it with "qconf -sstnode qconf_proj"
#                                Then delete it with "qconf -dstnode qconf_proj"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# performance/large_cluster/check.exp/large_cluster_setup_sharetree()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_show_delete_stnode {} {
   global ts_config env 
   global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER

   set hosts [host_conf_get_suited_hosts 2]
   set host       [lindex $hosts 0]
   set other_host [lindex $hosts 1]

   set project "mytestproject"

   # Submit a dummy job to make sure we have a user list
   # (user will be automatically created)
   submit_job "-o /dev/null -j y $ts_config(product_root)/examples/jobs/sleeper.sh 1"

   # Add users
   # Some of them might already exist - in this case we call mod_user
   get_user_list current_user_list
   ts_log_fine "Adding  user $CHECK_USER to project $project ...\n"

   foreach user "$CHECK_USER $CHECK_FIRST_FOREIGN_SYSTEM_USER" {
      if {[info exists new_user]} {
         unset new_user
      }
      ts_log_fine "Adding  user $user to project $project ...\n"
      set new_user(default_project) $project
      if {[lsearch -exact $current_user_list $user] < 0} {
         add_user "$user" new_user 1
      } else {
         mod_user "$user" new_user 1
      }
   }

   # Now add policies to the project $project
   ts_log_fine "Adding  30 shares to $CHECK_USER to project $project and 70 shares to $CHECK_FIRST_FOREIGN_SYSTEM_USER...\n"
   set result1 [add_sharetree_node $project $CHECK_USER 30 $CHECK_FIRST_FOREIGN_SYSTEM_USER 70]

   if { ( $result1 == 0 ) } {
      ts_log_fine "qconf -astnode /$project succeded"
   } else {
      ts_log_fine "result is $result1"
   }
  
   # Now do a negative test on -astnode, add users again
   ts_log_fine "Adding  30 shares to $CHECK_USER to project $project and 70 shares to $CHECK_FIRST_FOREIGN_SYSTEM_USER again....n"
   set result2 [add_sharetree_node $project $CHECK_USER 30 $CHECK_FIRST_FOREIGN_SYSTEM_USER 70 $host $CHECK_USER 0]

   if { ( $result2 == 0 ) } {
      ts_log_fine "qconf -astnode /$project again succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   # Now show the sharetree list
   ts_log_fine "Now show sharetree list for $project... \n"
   set result3 [get_sharetree_list $project]

   if { ( $result3 == 0 ) } {
      ts_log_fine "qconf -sstnode /$project succeded"
   } else {
      ts_log_fine "result is $result3"
   }

   # Modify shares in project $project
   ts_log_fine "Now modify shares for user $CHECK_USER, $CHECK_FIRST_FOREIGN_SYSTEM_USER for  $project... \n"
   set result4 [mod_sharetree_node $project $CHECK_USER 50 $CHECK_FIRST_FOREIGN_SYSTEM_USER 50]

   if { ( $result4 == 0 ) } {
      ts_log_fine "qconf -mstnode /$project succeded"
   } else {
      ts_log_fine "result is $result4"
   }

   # Now show the sharetree list again
   ts_log_fine "Now show sharetree list for $project again... \n"
   set result5 [get_sharetree_list $project]
   if  { ( $result5 == 0 ) } {
      ts_log_fine "qconf -sstnode /$project again succeded"
   } else {
      ts_log_fine "result is $result5"
   }

   
   # Delete $project/$CHECK_USER
   ts_log_fine "Now  delete user $CHECK_USER from  $project ... \n"
   set result6 [del_sharetree_node $project  $CHECK_USER]
  
   if { ( $result6 == 0 ) } {
      ts_log_fine "qconf -dstnode /$project/$CHECK_USER succeded"
   } else {
      ts_log_fine "result is $result6"
   }

   # Delete $project/$CHECK_FIRST_FOREIGN_SYSTEM_USER
   ts_log_fine "Now  delete user $CHECK_FIRST_FOREIGN_SYSTEM_USER from  $project ... \n"
   set result6 [del_sharetree_node $project  $CHECK_FIRST_FOREIGN_SYSTEM_USER]

   if { ( $result6 == 0 ) } {
      ts_log_fine "qconf -dstnode /$project/$CHECK_FIRST_FOREIGN_SYSTEM_USER succeded"
   } else {
      ts_log_fine "result is $result6"
   }
   
   # Delete users CHECK_USER, CHECK_FIRST_FOREIGN_SYSTEM_USER from userlist
   ts_log_fine "Now  delete user $CHECK_USER from  userlist ... \n"
   del_user $CHECK_USER
   ts_log_fine "Now  delete user $CHECK_FIRST_FOREIGN_SYSTEM_USER from  userlist ... \n"
   del_user $CHECK_FIRST_FOREIGN_SYSTEM_USER
}


#                                                             max. column:     |
#****** qconf/qconf_event_client() ******
#
#  NAME
#     qconf_event_client - Create and then destroy an event client
#
#  SYNOPSIS
#     qconf_event_client { } - First create an INTERACTIVE only queue
#                             Then start qevent -ts as CHECK_USER
#                             Check event client list with qconf -secl
#			                     Then kill event client with qconf -kec
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# performance/throughput/run_throughput_test()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_event_client {} {
   global ts_config env
   global CHECK_USER 

   set event_client_bin [get_test_or_source_path "qevent" $ts_config(master_host)]

   if { [file isfile $event_client_bin] != 1 } {
      ts_log_config "could not open event client binary: $event_client_bin"
      return -3
   }
   ts_log_fine "using event client: $event_client_bin"

   # start event client on master host
   ts_log_fine "starting event client with -ts option ..."
   set event_client_sid [ open_remote_spawn_process $ts_config(master_host) $CHECK_USER $event_client_bin "-ts"]
   set event_client_id [lindex $event_client_sid 1]

   # First do a list of event clients
   ts_log_fine "Show event client with -secl option ..."
   set result0 [get_event_client_list ]

   if {$result0 == 0} {
      ts_log_fine "qconf -secl succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   # Kill now event clients

   set result1 [del_event_client_list "" $event_client_id]

   if {$result1 == 0} {
      ts_log_fine "qconf -kec $event_client_id succeded"
   } else {
      ts_log_fine "result is $result1"
   }

   close_spawn_process $event_client_sid
   
   # Restart event client to do a -kec all

   # start event client on master host
   ts_log_fine "Re-starting event client with -ts option ..."
   set event_client_sid1 [ open_remote_spawn_process $ts_config(master_host) $CHECK_USER $event_client_bin "-ts"]
   set event_client_id1 [lindex $event_client_sid1 1]

   set result2 [del_event_client_list "all" ""]

   if {$result2 == 0} {
      ts_log_fine "qconf -kec all succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   close_spawn_process $event_client_sid1
}

#****** qconf/qconf_add_delete_modify_calendar() ******
#
#  NAME
#     qconf_add_delete_modify_calendar - Create modify then destroy a calendar
#
#  SYNOPSIS
#     qconf_add_delete_modify_calendar { } - First create a calendar, interactively
#                                            Then modify it and delete it.
#                                            Then create it in fast add mode, 
#                                            Then delete it again
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# performance/throughput/run_throughput_test()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_delete_modify_calendar {} {
   global ts_config env
   global CHECK_USER 

   set cal_name "qconf_calendar"
   set new_cal(week)           "mon-sun=0-24=suspended"

   # First do a list of event clients
   ts_log_fine "Add calendar $cal_name ..."
   set result0 [add_calendar "$cal_name" new_cal]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -Acal succeded"
   } else {
      ts_log_fine "result is $result0"
   }
  
   set mod_cal(calendar_name)  "$cal_name"
   set mod_cal(week)           "mon-fri=0-23=suspended"

   # Now modify it 
   ts_log_fine "Modify calendar $cal_name ..."
   set result01 [mod_calendar "$cal_name" mod_cal]

   if { ( $result01 == 0 ) } {
      ts_log_fine "qconf -Mcal succeded"
   } else {
      ts_log_fine "result is $result01"
   }

   # Now delete it 
   ts_log_fine "Delete calendar $cal_name ..."
   set result1 [del_calendar $cal_name]

   if { ( $result1 == 0 ) } {
      ts_log_fine "qconf -dcal succeded"
   } else {
      ts_log_fine "result is $result1"
   }
  
   # Now do a slow add
   ts_log_fine "Add calendar $cal_name slow..."
   set result2 [add_calendar "$cal_name" new_cal 0]

   if { ( $result2 == 0 ) } {
      ts_log_fine "qconf -acal slow succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   # Now modify it slow
   ts_log_fine "Modify calendar $cal_name slow..."
   set result21 [mod_calendar "$cal_name" mod_cal 0]

   if { ( $result21 == 0 ) } {
      ts_log_fine "qconf -mcal slow  succeded"
   } else {
      ts_log_fine "result is $result21"
   }

   # Now delete it  again
   ts_log_fine "Delete calendar $cal_name again..."
   set result3 [del_calendar $cal_name]

   if { ( $result3 == 0 ) } {
      ts_log_fine "qconf -dcal again succeded"
   } else {
      ts_log_fine "result is $result3"
   }
}

#****** qconf/qconf_add_delete_modify_replace_attr() ******
#
#  NAME
#     qconf_add_delete_modify_replace_attr - Create modify then destroy attributes of object queue qocnf_queue.q . Can also be object exechost....
#
#  SYNOPSIS
#     qconf_add_delete_modify_replace_attr { } - First create a temporary queue, qocnf_queue.q
#                                            Then modify it and delete it.
#                                            Then create it in slow add mode
#                                            Then modify it slow and delete it 
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_attributes/get_attr()
# sge_attributes/mod_attr()
#*******************************
proc qconf_add_delete_modify_replace_attr {} {
   global ts_config env
   global CHECK_USER 

   set queue_name "qconf_queue.q"
   set host [host_conf_get_suited_hosts]

   # First create the queue
   ts_log_fine "Create  queue $queue_name ...\n"
   set result0 [add_queue $queue_name $host new_queue]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -aq  $queue_name succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   # Now test if qconf rejects an empty file for Mattr
   set obj_spec "queue"
   set attr_name ""
   set val ""
   set target [get_queue_instance $queue_name $host]

   ts_log_fine "Try fast add with empty file ..."
   set result01 [mod_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if {$result01 != -2} {
      ts_log_info "Negative test qconf -Mattr <emptyfile> Failed! $result01"
   } else {
      ts_log_fine "Negative test:qconf -Mattr <emptyfile> Success!"
   }   

   # Now modify attribute slots for obj_spec queue: -mattr queue slots 0 
   set attr_name "slots"
   set val "1"

   ts_log_fine "Modify $obj_spec  $attr_name  ..."
   set result01 [mod_attr  $obj_spec $attr_name $val $target]

   if { ( $result01 == 0 ) } {
      ts_log_fine "qconf -Mattr succeded"
   } else {
      ts_log_fine "result is $result01"
   }

   # Now modify non-existent attribute stuff 
   set attr_name "stuff"
   set val "100"

   ts_log_fine "Modify $obj_spec  $attr_name  ..."
   set result02 [mod_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if { ( $result02 == -1 ) } {
      ts_log_fine "qconf -Mattr with wrong attribute succeded"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1966
      ts_log_fine "result is $result02"
   }
  
   # Now modify its attribute from CLI
   set attr_name "slots"
   set val "1"
   ts_log_fine "Modify $obj_spec $attr_name from CLI ...\n"
   set result02 [mod_attr  $obj_spec $attr_name $val $target 0]

   if { ( $result02 == 0 ) } {
      ts_log_fine "qconf -mattr succeded"
   } else {
      ts_log_fine "result is $result02"
   }

  # Now modify its attribute from CLI wrongly
   set attr_name "stuff"
   set val "200"
   ts_log_fine "Modify $obj_spec $attr_name from CLI wrongly ...\n"
   set result03 [mod_attr  $obj_spec $attr_name $val $target 0 $host $CHECK_USER 0]

   if { ( $result03 == -1 ) } {
      ts_log_fine "qconf -mattr wrongly succeded"
   } else {
      ts_log_fine "result is $result03"
   }

   # Now show these attributes
   set attr_name "slots"
   set val "0"
   ts_log_fine "Show $obj_spec  $attr_name  ..."
   set result03 [get_attr $obj_spec $attr_name $target]

   if { ( $result03 == 0 ) } {
      ts_log_fine "qconf -sobjl succeded"
   } else {
      ts_log_fine "result is $result03"
   }

   # Now replace attribute slots for obj_spec queue: -Rattr queue slots 0
   ts_log_fine "Replace $obj_spec  $attr_name  ..."
   set result04 [replace_attr  $obj_spec $attr_name $val $target]

   if { ( $result04 == 0 ) } {
      ts_log_fine "qconf -Rattr succeded"
   } else {
      ts_log_fine "result is $result04"
   }

   # Now try to add wrong stuff
   set attr_name "stuff"
   set val "100"
   ts_log_fine "Add $obj_spec  $attr_name  slow..."
   set result21 [add_attr  $obj_spec $attr_name $val $target 0 $host $CHECK_USER 0]

   if { ( $result21 == -1 ) } {
      ts_log_fine "qconf -aattr wrongly succeded"
   } else {
      ts_log_fine "result is $result21"
   }

   # Now try to add wrong stuff fast
   ts_log_fine "Add $obj_spec  $attr_name  fast..."
   set result22 [add_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if { ( $result22 == -1 ) } {
      ts_log_fine "qconf -Aattr wrongly succeded"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1966
      ts_log_fine "result is $result22"
   }

   # Now replace non-existent attribute stuff
   set attr_name "stuff"
   set val "100"

   ts_log_fine "Replace $obj_spec  $attr_name  slow..."
   set result31 [replace_attr  $obj_spec $attr_name $val $target 0 $host $CHECK_USER 0]

   if { ( $result31 == -1 ) } {
      ts_log_fine "qconf -rattr wrongly succeded"
   } else {
      ts_log_fine "result is $result31"
   }

   # Now replace non-existent attribute stuff from file

   ts_log_fine "Replace $obj_spec  $attr_name from file  ..."
   set result32 [replace_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if { ( $result32 == -1 ) } {
      ts_log_fine "qconf -Rattr wrongly succeded"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1966
      ts_log_fine "result is $result32"
   }

   # Now try to delete non-existant stuff
   ts_log_fine "Delete  attr  $attr_name  slow..."
   set result31 [del_attr  $obj_spec $attr_name $val $target 0 $host $CHECK_USER 0]

   if { ( $result31 == -1 ) } {
      ts_log_fine "qconf -dattr wrongly succeded"
   } else {
      ts_log_fine "result is $result31"
   }

   # Now try to delete non-existant stuff fast
   ts_log_fine "Delete  attr  $attr_name  fast..."
   set result32 [del_attr  $obj_spec $attr_name $val $target 1 $host $CHECK_USER 0]

   if { ( $result32 == -1 ) } {
      ts_log_fine "qconf -Dattr wrongly succeded"
   } else {
      # handle_sge_errors will retun -999 due to multiple line
      # response from qconf. See IZ 1966
      ts_log_fine "result is $result32"
   }

   # Now delete it via -dattr using good values
   set attr_name "slots"
   set val "1"
   ts_log_fine "Delete attr $attr_name on $queue_name slow ...\n"
   set result22 [del_attr $obj_spec $attr_name $val $target 0]

   if { ( $result22 == 0 ) } {
      ts_log_fine "qconf -dattr slow succeded"
   } else {
      ts_log_fine "result is $result22"
   }

   # Now delete queue

   ts_log_fine "Delete queue $queue_name ..."
   set result4 [del_queue  $queue_name $host 1]

   if { ( $result4  == 0 )} {
      ts_log_fine "qconf -dq $queue_name succeded"
   } else {
      ts_log_fine "result is $result4"
   }
}

#****** qconf/qconf_modify_checkpoint() ******
#
#  NAME
#     qconf_modify_checkpoint - Modify chekcpoint
#
#  SYNOPSIS
#     qconf_modify_checkpoint { } - Call "qconf -Mckpt "
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_procedures/get_scheduler_status()
#*******************************
proc qconf_modify_checkpoint {} {
   global ts_config env
   global CHECK_USER 

   # First let's create queue qconf_queue.q
   set queue_name "qconf_queue.q"
   ts_log_fine "Create  queue $queue_name ..."

   set host [host_conf_get_suited_hosts]
   set result0 [add_queue $queue_name $host new_queue]

   if {$result0 == 0} {
      ts_log_fine "qconf -Aq  $queue_name succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   # Next, let's create a checkpoint
   set CKPT_NAME "qconf_ckpt_name"
   ts_log_fine "Create  checkpoint  $CKPT_NAME ..."

   set result1 [add_ckpt $CKPT_NAME]

   if {$result1 == 0} {
      ts_log_fine "qconf -ackpt  succeded"
   } else {
      ts_log_fine "result is $result1"
   }

   # Now modify it using set_checkpointobj
   set myarray(clean_command) "ls"
   ts_log_fine "Modify checkpoint $CKPT_NAME ..."
   set result2 [mod_ckpt $CKPT_NAME myarray 1]

   if {$result2 == 0} {
      ts_log_fine "qconf -Mckpt succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   # Now modify it using CLI
   set myarray(clean_command) "none"
   ts_log_fine "Modify checkpoint $CKPT_NAME using CLI..."
   set result21 [mod_ckpt $CKPT_NAME myarray 0]

   if {$result21 == 0} {
      ts_log_fine "qconf -mckpt succeded"
   } else {
      ts_log_fine "result is $result21"
   }

   # Now try to modify using a non-existent checkpoint
   set CKPT_NAME "qconf_ckpt_wrong"
   ts_log_fine "Modify wrong checkpoint $CKPT_NAME ..."
   set result21 [mod_ckpt $CKPT_NAME myarray 1 "" "" 0]

   if {$result21 == -1} {
      ts_log_fine "qconf -Mckpt failed correctly"
   } else {
      ts_log_fine "result is $result21"
   }

   # Now try to modify using a non-existent checkpoint slow
# TODO: we have to modify the way how handle_vi_edit works.
#       at least, handle_vi_edit has to accept multiple error messages.
#       Best might be to pass arrays of messages to handle_vi_edit, similar to
#       handle_sge_error.
#   ts_log_fine "Modify wrong checkpoint $myarray(ckpt_name) slow ...\n"
#   set result22 [mod_ckpt $myarray(ckpt_name) myarray 0 "" "" 0]
#
#   if {$result22 == -9} {
#      ts_log_fine "qconf -mckpt failed correctly"
#   } else {
#      ts_log_fine "result is $result22"
#   }

   # Now delete checkpoint
   set CKPT_NAME "qconf_ckpt_name"
   ts_log_fine "Delete checkpoint $CKPT_NAME ..."
   set result4 [del_ckpt $CKPT_NAME]

   if {$result4 == 0} {
      ts_log_fine "qconf -dckpt $CKPT_NAME succeded"
   } else {
      ts_log_fine "result is $result4"
   }

   # Now delete queue
   ts_log_fine "Delete queue $queue_name ..."
   set result8 [del_queue  $queue_name $host 1]

   if {$result8 == 0} {
      ts_log_fine "qconf -dq $queue_name succeded"
   } else {
      ts_log_fine "result is $result8"
   }
}

#****** qconf/qconf_modify_exechost() ******
#  NAME
#     qconf_modify_exechost - Modify exec host
#
#  SYNOPSIS
#     qconf_sep_check { } - Call set_exechost to modify exechost
#                         from CLI or file
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_processor_list()
#*******************************
proc qconf_modify_exechost {} {
   global ts_config env
   global CHECK_USER

   set host [host_conf_get_suited_hosts]

   # Save the initial values
   get_exechost old_values $host

   # First create project qconf_test_prj
   set my_project "qconf_test_prj"
   ts_log_fine "Create project $my_project ...\n"
   set result [add_project "$my_project"]
   ts_log_fine $result

   # Modify exechost fast
   ts_log_fine "Modify exec host  $host  from file ...\n"
   set new_exechost_charray(projects) "$my_project"
   set result0 [mod_exechost new_exechost_charray $host]

  if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -Me succeded\n"
   } else {
      ts_log_fine "result is $result0"
   }

   # Now modify from CLI
   ts_log_fine "Modify exec host $host from CLI ...\n"
   set result1 [mod_exechost new_exechost_charray $host 0]

  if { ( $result1 == 0 ) } {
      ts_log_fine "qconf -me succeded\n"
   } else {
      ts_log_fine "result is $result1"
   }

   # Modify exechost fast wrongly
   ts_log_fine "Modify exec host  $host  from file wrongly...\n"
   set new_exechost_charray(projects) "qconf_wrong_prj"
   set result1 [mod_exechost new_exechost_charray $host 1 $host $CHECK_USER 0]

  if { ( $result1 == -1 ) } {
      ts_log_fine "qconf -Me failed  successfully \n"
   } else {
     # See IZ 1967 for why this returns wrongly 0
     ts_log_fine "result is $result1"
   }
   
   # Now modify from CLI wrongly
   ts_log_fine "Modify exec host $host from CLI wrongly...\n"
   set result12 [mod_exechost new_exechost_charray $host 0 $host $CHECK_USER 0]

  if { ( $result12 == -3 ) } {
      ts_log_fine "qconf -me failed  successfully\n"
   } else {
      ts_log_fine "result is $result12"
   }

   # Now restore the old values
   ts_log_fine "Restoring old values for  $host  ...\n"
   set result2 [mod_exechost old_values $host 0]

  if { ( $result2 == 0 ) } {
      ts_log_fine "qconf -me succeded\n"
   } else {
      ts_log_fine "result is $result2"
   }
  
  # Now delete project qconf_test_prj
   ts_log_fine "Delete project $my_project ...\n"
   set result [del_project $my_project]
}

#****** qconf/qconf_modify_project() ******
#
#  NAME
#     qconf_modify_project - Modify project's fshare
#
#  SYNOPSIS
#     qconf_modify_project { } - Call mod_project
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_modify_project {} {
   global ts_config qconf_project

   set my_project "$qconf_project"

   # Next modify fast
   ts_log_fine "Modify project $my_project fast ...\n"
   set old_values(fshare) "0"
   set result1 [mod_project $my_project old_values]

   if {$result1 == 0} {
      ts_log_fine "qconf -Mprj $my_project succeded"
   } else {
      ts_log_fine "result is $result1"
   }

   # Next modify slow
   ts_log_fine "Modify project $my_project slow ...\n"
   set result2 [mod_project $my_project old_values 0]

   if {$result2 == 0} {
      ts_log_fine "qconf -mprj $my_project succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   # Next modify fast wrong
   ts_log_fine "Modify project $my_project fast with wrong attribute  ...\n"
   set old_values(stuff) "5"
   set result21 [mod_project $my_project old_values 1 "" "" 0]

   if {$result21 == -1} {
      ts_log_fine "qconf -Mprj $my_project failed  correctly"
   } else {
      # See IZ 1968 on why this does not fail as expected
      ts_log_fine "result is $result21"
   }

   # Next modify fast wrong again
   ts_log_fine "Modify project $my_project wrong fast again ...\n"
   set old_values(fshare) "-1"

   set result3 [mod_project $my_project old_values 1 "" "" 0]

   if {$result3 == -2} {
      ts_log_fine "qconf -Mprj $my_project failed again correctly"
   } else {
      # See IZ 1968 on why this does not fail as expected
      ts_log_fine "result is $result3"
   }

   # Next modify slow
   ts_log_fine "Modify project $my_project  wrong slow ...\n"
   set result4 [mod_project $my_project old_values 0 "" "" 0]

   if {$result4 == -3} {
      ts_log_fine "qconf -mprj $my_project failed  correctly"
   } else {
      ts_log_fine "result is $result4"
   }
}

#****** qconf/qconf_modify_userlist() ******
#
#  NAME
#     qconf_modify_userlist - Modify userlist's fshare
#
#  SYNOPSIS
#     qconf_modify_userlist { } - Call mod_userlist
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_modify_userlist {} {
   global ts_config env qconf_userlist
   global CHECK_USER

   set host [host_conf_get_suited_hosts]
  
   set userlist "qconf_userlist"
   set attribute "entries"
   set value $CHECK_USER

   set current_ul(name) $userlist
   set current_ul($attribute) $value

   # Now modify fast
   ts_log_fine "1) Modify userlist $userlist fast"
   set result [mod_userlist $userlist current_ul]

   # Next modify slow
   set attribute "entries"
   set value "NONE"
   set current_ul($attribute) $value
   ts_log_fine "2) Modify userlist $userlist slow"
   set result [mod_userlist $userlist current_ul 0]

   # Now modify slow with wrong attribute
   # this verification is only implemented for 6.1u4 and higher
   set userlist "qconf_userlist"
   set attribute "oticket"
   set value -1
   set current_ul($attribute) $value
   ts_log_fine "3) Modify attribute $attribute wrong slow"
   set result [mod_userlist $userlist current_ul 0 $host $CHECK_USER 0]

   if {$result != -12} {
      ts_log_severe "qconf -mu didn't fail as expected"
   }

   # Now modify fast with wrong value
   ts_log_fine "4) Modify userlist $userlist wrong fast ..."
   set result [mod_userlist $userlist current_ul 1 $host $CHECK_USER 0]

   if {$result != -12} {
      ts_log_severe "qconf -Mu didn't fail as expected"
   }

   #test if setting wrong value in userset type throws error
   set attribute "oticket"
   set value "0"
   set current_ul($attribute) "$value"
   set attribute "type"
   set value "BADTYPE"
   set current_ul($attribute) "$value"
   ts_log_fine "5) Setting invalid type for userset ..."
   set result [mod_userlist $userlist current_ul 0 $host $CHECK_USER 0]

   if {$result != -7} {
      ts_log_severe "qconf -mu for invalid userset type didn't fail as expected"
   }

   #test if setting blank value in userset type throws error
   set value "    "
   set current_ul($attribute) "$value"
   ts_log_fine "6) Setting blank type for userset ..."
   set result [mod_userlist $userlist current_ul 0 $host $CHECK_USER 0]

   if {$result != -11} {
      ts_log_severe "qconf -mu for blank userset type didn't fail as expected"
   }
}

#****** qconf/qconf_modify_sched_conf() ******
#
#  NAME
#     qconf_modify_sched_conf - Modify scheduler config
#
#  SYNOPSIS
#     qconf_modify_sched_conf { } - Call mod_schedd_config
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_modify_sched_conf {} {
   global ts_config env 
   global CHECK_USER

   set host [host_conf_get_suited_hosts]

   # Next modify fast
   set mysched_config(maxujobs) "10"

   ts_log_fine "Modify schedd fast ...\n"
   set result1 [mod_schedd_config mysched_config ]

   if { ( $result1 == 0 ) } {
      ts_log_fine "qconf -Msconf succeded"
   } else {
      ts_log_fine "result is $result1"
   }

   # Next modify slow
   set mysched_config(maxujobs) "5"
   ts_log_fine "Modify schedd slow ...\n"
   set result2 [mod_schedd_config mysched_config 0]

   if { ( $result2 == 0 ) } {
      ts_log_fine "qconf -msconf succeded"
   } else {
      ts_log_fine "result is $result2"
   }

   # Next modify slow with wrong values
   set mysched_config(maxujobs) "-1"
   ts_log_fine "Modify schedd slow ...\n"
   set result3 [mod_schedd_config mysched_config 0 $host $CHECK_USER 0]

   if { ( $result3 == -2 ) } {
      ts_log_fine "qconf -msconf failed successfully"
   } else {
      ts_log_fine "result is $result3"
   }

   # Next modify fast with wrong values
   ts_log_fine "Modify schedd fast ...\n"
   set result4 [mod_schedd_config mysched_config 1 $host $CHECK_USER 0]

   if { ( $result4 == -1 ) } {
      ts_log_fine "qconf -Msconf failed successfully"
   } else {
      # See IZ 1975 on why this does not fail as expected
      ts_log_fine "result is $result4"
   }
}

#****** qconf/qconf_issue_2023() ******
#
#  NAME
#     qconf_issue_2023 - Test for Issue 2023
#
#  SYNOPSIS
#     qconf_issue_2023 { } - 
#
#  FUNCTION
#     Check qconf issue 2023 
#
#*******************************
proc qconf_issue_2023 {} {
   global ts_config env qconf_userlist
   global CHECK_USER

   set host [host_conf_get_suited_hosts]
  
   set userlist "qconf_userlist"
   set attribute "entries"
   set value "$CHECK_USER"

   set current_ul(name) "$userlist"
   set current_ul($attribute) "$value "

   set result1 [mod_userlist $userlist current_ul ]
   if { ( $result1 != 0 ) } {
      ts_log_severe "rejects configuration, when attribute value ends with a space character"
      ts_log_fine "result is $result1"
   }
}

#****** check/qconf_create_modify_sharetree() **********************************
#  NAME
#     qconf_create_modify_sharetree() -- test qconf -Mstree
#
#  SYNOPSIS
#     qconf_create_modify_sharetree { } 
#
#  FUNCTION
#     Tests qconf -Mstree option.
#     Positive tests adding a new sharetree and modifying a sharetree.
#
#     Negative tests as non admin user and from a non admin host.
#*******************************************************************************
proc qconf_create_modify_sharetree {} {
   global ts_config
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   # delete an already existing sharetree
   del_sharetree

   # create a sharetree
   stree_buffer_init stree
   stree_buffer_add_node stree "/default" 10
   stree_buffer_add_node stree "/mytestproject" 20
   stree_buffer_add_node stree "/mytestproject/default" 30
   stree_buffer_commit stree

   # modify the sharetree
   stree_buffer_mod_node stree "/default" 20
   stree_buffer_del_node stree "/mytestproject"
   stree_buffer_commit stree

   # read in the sharetree - it may only contain the / and the /default nodes
   # with correct number of shares
   stree_buffer_read stree2
   if {[llength $stree2(index)] != 2 || 
       [lindex $stree2(index) 0] != "/" || 
       [lindex $stree2(index) 1] != "/default"} {
      ts_log_severe "sharetree should only contain the nodes / and /default, but contains\n$stree2(index)"
   }

   # delete the sharetree
   del_sharetree

   # try to create/modify a sharetree with insufficient permissions
   # - as non admin user
   # - from non admin host
   set ret [stree_buffer_commit stree "" $CHECK_FIRST_FOREIGN_SYSTEM_USER 0]
   if {$ret != -210 && $ret != -214} {
      ts_log_severe "qconf -Mstree should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   }
   set non_cluster_host [host_conf_get_non_cluster_host]
   if {$non_cluster_host != ""} {
      set ret [stree_buffer_commit stree $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $ret "admin"]} {
         ts_log_severe "qconf -Mstree should have failed on host $non_cluster_host"
      }
   }

   # delete a sharetree created due to errors in the permission check
   del_sharetree
}

#****** check/qconf_del_sharetree() ********************************************
#  NAME
#     qconf_del_sharetree() -- test qconf -dstree
#
#  SYNOPSIS
#     qconf_del_sharetree { } 
#
#  FUNCTION
#     Tests qconf -dstree.
#     Positive test with and without sharetree.
#     
#     Negative tests as non admin user and from a non admin host.
#*******************************************************************************
proc qconf_del_sharetree {} {
   global ts_config
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   # delete an already existing sharetree
   del_sharetree

   # build a sharetree and delete it - must give error code 0
   stree_buffer_init stree
   stree_buffer_add_node stree "/default" 10
   stree_buffer_add_node stree "/mytestproject" 20
   stree_buffer_add_node stree "/mytestproject/default" 30
   stree_buffer_commit stree

   set ret [del_sharetree]
   if {$ret != 0} {
      ts_log_severe "qconf -dstree should have reported success"
   }

   # test qconf action when there is no sharetree to delete
   set ret [del_sharetree]
   if {$ret != 1} {
      ts_log_severe "qconf -dstree should have reported \"No sharetree\""
   }

   # try to delete a sharetree with insufficient permissions
   # - as non admin user
   # - from non admin host
   stree_buffer_commit stree
   set ret [del_sharetree "" $CHECK_FIRST_FOREIGN_SYSTEM_USER 0]
   if {$ret != -210 && $ret != -214} {
      ts_log_severe "qconf -dstree should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   }
   set non_cluster_host [host_conf_get_non_cluster_host]
   if {$non_cluster_host != ""} {
      set ret [del_sharetree $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $ret "admin"]} {
         ts_log_severe "qconf -dstree should have failed on host $non_cluster_host"
      }
   }

   # delete the sharetree
   del_sharetree

   # now there may be no sharetree, make sure the correct error message is
   # returned by qconf -sstree
   set msg [translate_macro MSG_OBJ_NOSTREEELEM]
   set output [string trim [start_sge_bin "qconf" "-sstree"]]
   if {![string match $msg $output]} {
      ts_log_severe "qconf -sstree should have output\n$msg\nbut got\n$output"
   }
}

#****** check/qconf_add_project() **********************************************
#  NAME
#     qconf_add_project() -- test qconf -aprj / -Aprj
#
#  SYNOPSIS
#     qconf_add_project { } 
#
#  FUNCTION
#     Test adding projects (qconf -aprj and qconf -Aprj).
#     Positive tests.
#
#     Negative tests creating duplicates and project name being a keyword,
#     and as non admin user and from a non admin host.
#*******************************************************************************
proc qconf_add_project {} {
   global ts_config
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   # test adding projects
   set MY_PROJECT_NAME "qconf_add_prj"

   add_project "$MY_PROJECT_NAME" project 0 ;# slow add
  
   del_project "$MY_PROJECT_NAME"

   add_project "$MY_PROJECT_NAME"  ;# fast add

   # test adding duplicates (must fail)
   # TODO: it's difficult to handle all the default error conditions
   # in handle_vi_edit (e.g. host and user permissions).
   # until this is fixed, we cannot do negative tests with qconf calling the editor.
   #set ret [add_project $MY_PROJECT_NAME project 0 "" "" 0] ;# slow add duplicate
   #if {$ret != -2} {
   #   ts_log_severe "qconf -aprj should have failed for duplicate"
   #}

   set ret [add_project "$MY_PROJECT_NAME" project 1 "" "" 0] ;# fast add duplicate
   if {$ret != -2} {
      ts_log_severe "qconf -Aprj should have failed for duplicate"
   }

   del_project "$MY_PROJECT_NAME"

   # test other errors
   set MY_PROJECT_NAME "default"
   #set ret [add_project "$MY_PROJECT_NAME" project 0 "" "" 0] ;# slow add incorrect prj (name is keyword)
   #if {$ret >= 0} {
   #   ts_log_severe "qconf -aprj should have failed for a project named \"default\""
   #}

   set ret [add_project "$MY_PROJECT_NAME" project 1 "" "" 0] ;# fast add incorrect prj (name is keyword)
   if {$ret >= 0} {
      ts_log_severe "qconf -Aprj should have failed for a project named \"default\""
   }

   # try to add a project with insufficient permissions
   # - as non admin user
   # - from non admin host
   set MY_PROJECT_NAME "qconf_add_prj"
   set ret [add_project "$MY_PROJECT_NAME" project 1 "" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" 0]
   if {$ret != -210 && $ret != -214} {
      ts_log_severe "qconf -Aprj should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   }

   set non_cluster_host [host_conf_get_non_cluster_host]
   set ret [add_project "$MY_PROJECT_NAME" project 0 $non_cluster_host "" 0]
   #if {$ret != -201} {
   #   ts_log_severe "qconf -aprj should have failed on host $non_cluster_host"
   #}

   if {$non_cluster_host != ""} {
      set ret [add_project "$MY_PROJECT_NAME" project 1 $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $ret "admin"]} {
         ts_log_severe "qconf -Aprj should have failed on host $non_cluster_host"
      }
   }
}

proc qconf_brief_exercise {} {
   global ts_config

   ts_log_fine "* * * PROJECT * * *"
   set right_param(oticket) "10"
   qconf_messages_basic_check project right_param
   unset right_param

   ts_log_fine "* * * USERSET * * *"
   set right_param(type) "ACL DEPT"
   qconf_messages_basic_check userset right_param
   unset right_param
   # aja: TODO: adjust the functional tests
   add_access_list "user1 user2 user3" "set1,set2"
   del_user_from_access_list "user4" "set1" "" "" 0                             ;# del user nonex. user err
   del_user_from_access_list "user1" "set3" "" "" 0                             ;# del user nonex. acl err
   del_user_from_access_list "user1" "set1" "" "" 0                             ;# del user nonex. acl ok
   del_user_from_access_list "user1 user2" "set2" "" "" 0                       ;# del user mix error
   del_access_list "set1,set2" "" "" 0                                          ;# del acl ok

   ts_log_fine "* * * PARALLEL ENVIRONMENT * * *"
   set right_param(slots) "10"
   qconf_messages_basic_check pe right_param
   unset right_param

   ts_log_fine "* * * CALENDAR * * *"
   set right_param(week) "mon-sun=0-24=off"
   qconf_messages_basic_check calendar right_param
   unset right_param

   ts_log_fine "* * * HOSTGROUP * * *"
   set right_param(hostlist)       "@allhosts"
   set args(name_prefix) "@"
   qconf_messages_basic_check hostgroup right_param args
   unset right_param
   unset args

   ts_log_fine "* * * USER * * *"
   set right_param(oticket) "10"
   qconf_messages_basic_check user right_param
   unset right_param
   # aja: TODO: test the rest functionality

   ts_log_fine "* * * QUEUE * * *"
   set right_param(load_thresholds)       "np_load_avg=7.0"
   set args(hostlist) $ts_config(master_host)
   set args(ignore_hostlist) 1
   set args(del_cqueue) 1
   qconf_messages_basic_check queue right_param args
   unset right_param
   unset args

}

#****** check.exp/qconf_messages_basic_check() *********************************
# 
#  NAME
#     qconf_messages_basic_check - basic test of qconf interfaces and the 
#                                  messages returned by the qconf client.
#
#  SYNOPSIS
#     qconf_messages_basic_check { object valid_object_params args }
#
#  FUNCTION
#     check the basic functionality of qconf command, play with the objects and
#     the returned messages from qconf client. 
#
#  INPUTS
#     object              - the name of the object 
#                           [ex.: project, user, hostgroup, queue, ...]
#     valid_object_params - the array with the valid attributes to check the 
#                           successfull add/mod functions
#                           object <name> parameter is ignored for this test, but
#                           can be set to check the name validation (not yet 
#                           implemented)
#     {arguments ""}      - array with additional arguments
#                           expected: 
#                               o name_prefix - i.e. @ for hostgroups
#                               o hostlist - i.e. for queues
#
#*******************************************************************************
proc qconf_messages_basic_check {object valid_object_params {arguments ""}} {
   upvar $valid_object_params ok_param
   upvar $arguments args

   explore_expected_arguments args name_prefix hostlist ignore_hostlist del_cqueue

   set obj_name_attr [get_object_name_attribute $object]
   # set the valid name for the object
   set object_name fake_${object}
   if {![string match "$name_prefix*" $object_name]} {
         set object_name ${name_prefix}${object_name}
   }

   set param($obj_name_attr) $object_name
   # required attributes - set the default value
   set_${object}_defaults object_defaults
   if {[info exist object_defaults(hostlist)]} {
      set param(hostlist) "NONE"
   }

   # check the get_$object_list function
 #  qconf_check_list $object param args
   # check invalid name for the object
   # aja: TODO: other name validation
   if {[string compare $name_prefix ""] != 0} {
      eval add_${object} test_${object} $hostlist param 0 "\"\"" "\"\"" 0       ;# add $object wrong name slow err
      eval add_${object} test_${object} $hostlist param 1 "\"\"" "\"\"" 0       ;# add $object wrong name fast err
   }
   # add/mod/del/get object game
   eval del_${object} $object_name $hostlist $ignore_hostlist $del_cqueue "\"\"" "\"\"" 0 ;# del nonex. $object err
   eval get_${object} $object_name out "\"\"" "\"\"" 0                          ;# get nonex. $object err
   eval mod_${object} ${object_name} $hostlist param 0 "\"\"" "\"\"" 0          ;# mod nonex. $object slow err
   eval mod_${object} $object_name $hostlist param 1 "\"\"" "\"\"" 0            ;# mod nonex. $object fast err
   eval add_${object} $object_name $hostlist param 0                            ;# add $object slow ok
   eval add_${object} $object_name $hostlist param 0 "\"\"" "\"\"" 0            ;# add already exists $object slow err
   eval mod_${object} $object_name $hostlist param 0 "\"\"" "\"\"" 0            ;# mod file unchanged slow err
   eval mod_${object} $object_name $hostlist param 1 "\"\"" "\"\"" 0            ;# mod file unchanged fast err
   # now we use the array with the valid attributes and parameters
   foreach elem [array names ok_param] {
      # we don't want to check the object name change
      if {[string compare $elem $obj_name_attr] != 0} {
         if {[info exists param($elem)]} {
            set bckp_param($elem) $param($elem)
         }
         set param($elem) $ok_param($elem)
      }
   }
   eval mod_${object} $object_name $hostlist param 0                            ;# mod $object slow ok
   eval del_${object} $object_name $hostlist $ignore_hostlist $del_cqueue       ;# del $object ok
   eval add_${object} $object_name $hostlist param                              ;# add $object fast ok
   # for the test of successfull modification change back the parameters
   foreach elem [array names bckp_param] {
      set param($elem) $bckp_param($elem)
   }
   eval mod_${object} $object_name $hostlist param 1                            ;# mod $object fast ok
   eval add_${object} $object_name $hostlist param 1 "\"\"" "\"\"" 0            ;# add already exists $object fast err
   eval del_${object} $object_name $hostlist $ignore_hostlist $del_cqueue       ;# del $object ok
   # let's test the wrong parameters
   set test_attributes ""
   # ulong attributes
   lappend test_attributes "oticket"
   lappend test_attributes "fshare"
   lappend test_attributes "slots"
   lappend test_attributes "delete_time"
   # userset dependent attributes
   lappend test_attributes "acl"
   lappend test_attributes "xacl"
   lappend test_attributes "user_lists"
   lappend test_attributes "xuser_lists"
   # project dependent attributes
   lappend test_attributes "default_project"
   # calendar attributes
   lappend test_attributes "year"
   lappend test_attributes "week"
   # host attributes
   lappend test_attributes "hostlist"
   # directory attributes
   lappend test_attributes "start_proc_args"
   lappend test_attributes "stop_proc_args"
   # complex attributes
   lappend test_attributes "load_thresholds"
   # aja: TODO: add attributes for testing (queue, pe,...)

   foreach attr $test_attributes {
      if {[info exists object_defaults($attr)]} {
         qconf_check_wrong_parameter $object param "$attr" args
      }
   }

   # aja: TODO: test missing required attribute
   # aja: TODO: test non-existing attribute   
}

#****** check.exp/qconf_check_list() *******************************************
# 
#  NAME
#     qconf_check_list - basic test of qconf get <object> list function.
#
#  SYNOPSIS
#     qconf_check_list { object valid_object_params args }
#
#  FUNCTION
#     basic test of qconf get <object> list function - either when any object
#     exists, or when no object exists
#
#  INPUTS
#     object              - the name of the object 
#                           [ex.: project, user, hostgroup, queue, ...]
#     valid_object_params - the array with the valid attributes to check the 
#                           successfull add/mod functions
#                           object <name> parameter is ignored for this test, but
#                           can be set to check the name validation (not yet 
#                           implemented)
#     {arguments ""}      - array with additional arguments
#                           expected: 
#                               o name_prefix - i.e. @ for hostgroups
#                               o hostlist - i.e. for queues
#     {referencies ""}    - ...
#
#  SEE ALSO
#      check.exp/qconf_messages_basic_check
#      check.exp/explore_expected_arguments
#*******************************************************************************
proc qconf_check_list {object valid_object_params {arguments ""} {referencies ""}} {
   upvar $valid_object_params valid_object
   set obj_name_attr [get_object_name_attribute $object]
   upvar $arguments args

   ts_log_fine "Basic test of get_${object}_list function"

   explore_expected_arguments args name_prefix hostlist ignore_hostlist del_cqueue

   # check if any object exist
   if {[eval get_${object}_list bckp "\"\"" "\"\"" 0] == 0} {
      # object exists
      if {[info exists bckp]} {
         set ind 0
         set all_count 0
         # Back up the existing objects
         foreach obj $bckp {
            incr all_count
            if { [eval get_${object} "$obj" "out$ind" "\"\"" "\"\"" 1] == 0 } { ;# get $object ok
                if {[eval del_${object} "$obj" $hostlist $ignore_hostlist $del_cqueue "\"\"" "\"\"" 0] == 0} {;# del $object ok
                  incr ind
               } else {
                  unset out$ind
                  # aja: TODO: referencies
               }
            } else {
            }
         }
         # test the nonex. object if the list is empty
         if {$ind == $all_count} {
            eval get_${object}_list out "\"\"" "\"\"" 0                         ;# get $object list err
         } else {
            ts_log_fine "get_${object}_list with nonex. $object not tested"
         }
         # Restore the objects
         for {set i 0} {$i < $ind} {incr i} {
            unset obj
            array set obj [array get out$i]
            if {[info exists obj(hostlist)]} {
               set hostlist $obj(hostlist)
            }
            eval add_${object} $obj($obj_name_attr) $hostlist obj               ;# add $object fast ok
            unset out$i
         }
         unset bckp
      }
   } else {
      # no object exists
      eval get_${object}_list out "\"\"" "\"\"" 0                               ;# get $object list err
      set oname "$valid_object($obj_name_attr)"
      if {![string match "$name_prefix*" $oname]} {
         set object_name ${name_prefix}${object_name}
      }
      eval add_${object} "$oname" $hostlist valid_object                        ;# add $object fast ok
      eval get_${object}_list                                                   ;# get $object list ok
      eval del_${object} "$oname" $hostlist $ignore_hostlist $del_cqueue        ;# del $object ok
   }

}
    
#****** check.exp/qconf_check_wrong_parameter() ********************************
# 
#  NAME
#     qconf_check_wrong_parameter - basic test of qconf mod/add functions 
#                                   with the wrong parameter
#
#  SYNOPSIS
#     qconf_check_wrong_parameter { object valid_object_params {arguments ""} }
#
#  FUNCTION
#     basic test of qconf get <object> list function - either when any object
#     exists, or when no object exists
#
#  INPUTS
#     object              - the name of the object 
#                           [ex.: project, user, hostgroup, queue, ...]
#     valid_object_params - the array with the valid attributes to check the 
#                           successfull add/mod functions
#                           object <name> parameter is ignored for this test, but
#                           can be set to check the name validation (not yet 
#                           implemented)
#     attribute           - attribute to change to invoke the wrong parameter
#                           error
#     {arguments ""}      - array with additional arguments
#                           expected: 
#                               o name_prefix - i.e. @ for hostgroups
#                               o hostlist - i.e. for queues
#     {value "universalNOTVALIDvalue"} - the wrong value for the attribute
#
#  SEE ALSO
#      check.exp/qconf_messages_basic_check
#*******************************************************************************
proc qconf_check_wrong_parameter {object valid_object_params attribute {arguments ""} {value "universalNOTVALIDvalue"}} {
   upvar $arguments args

   ts_log_fine "Check the add/mod $object functionality with the wrong parameter \"$attribute\""

   explore_expected_arguments args name_prefix hostlist ignore_hostlist del_cqueue

   set obj_name_attr [get_object_name_attribute $object]

   foreach elem [array names valid_object_param] {
      set param($elem) $valid_object_param($elem)
   }

   if {[info exists param($obj_name_attr)]} {
      set object_name param($obj_name_attr)
   } else {
      set object_name wrong_${object}
   }

   if {![string match "$name_prefix*" $object_name]} {
         set object_name ${name_prefix}${object_name}
   }

   eval add_${object} $object_name $hostlist param                              ;# add $object fast ok
   set param($attribute) $value
   if {[string compare $object "queue"] == 0 && [string compare $attribute "hostlist"] == 0} {
       set hostlist $value
   }
   eval mod_${object} $object_name $hostlist param 0 "\"\"" "\"\"" 0            ;# mod wrong param slow err
   eval mod_${object} $object_name $hostlist param 1 "\"\"" "\"\"" 0            ;# mod wrong param fast err
   eval del_${object} $object_name $hostlist $ignore_hostlist $del_cqueue       ;# del $object ok
   eval add_${object} $object_name $hostlist param 1 "\"\"" "\"\"" 0            ;# add wrong param fast err
   eval add_${object} $object_name $hostlist param 0 "\"\"" "\"\"" 0            ;# wrong param slow err

}

#****** check.exp/explore_expected_arguments() *********************************
# 
#  NAME
#     explore_expected_arguments - set the expected arguments
#
#  SYNOPSIS
#     explore_expected_arguments { arguments name_prefix hostlist }
#
#  FUNCTION
#     basic test of qconf get <object> list function - either when any object
#     exists, or when no object exists
#
#  INPUTS
#     arguments          - array with additional arguments
#                           expected: 
#                               o name_prefix - i.e. @ for hostgroups
#                               o hostlist - i.e. for queues
#     name_prefix         - variable for name_prefix argument
#     hostlist            - variable for hostlist argument
#     ignore_hostlist     - variable for del_queue function
#     del_cqueue          - variable for del_queue function
#
#*******************************************************************************
proc explore_expected_arguments {arguments name_prefix hostlist ignore_hostlist del_cqueue} {
   upvar $arguments args
   upvar $name_prefix nm
   upvar $hostlist hst
   upvar $ignore_hostlist ign
   upvar $del_cqueue dcq

   set hst ""
   set nm ""
   set ign ""
   set dcq ""
   foreach arg [array names args] {
      if {[string compare $arg "name_prefix"] == 0} {
         set nm $args($arg)
      }
      if {[string compare $arg "hostlist"] == 0} {
         set hst $args($arg)
      }
      if {[string compare $arg "ignore_hostlist"] == 0} {
         set ign $args($arg)
      }
      if {[string compare $arg "del_cqueue"] == 0} {
         set dcq $args($arg)
      }
   }
}

# set the attribure which holds the name of the object
proc get_object_name_attribute {object} {
   set obj_name_attr "name"
   set_${object}_defaults chgar
   foreach elem [array names chgar] {
      if {[string first "name" "$elem"] != -1} {
         set obj_name_attr "$elem"
         break
      }
   }
   return $obj_name_attr
}

#                                                             max. column:     |
#****** qconf/qconf_backslash_default_space_check() ******
# 
#  NAME
#     qconf_backslash_default_space_check -- tests backslash line continuation
#
#  SYNOPSIS
#     qconf_backslash_default_space_check { } 
#
#  FUNCTION
#     This function tests the parsing of backslash line continuation in files.
#     All files named backslash_setup_hostgroup* will be added as hostgroups
#     via "qconf -Ahgrp".  All files named backslash_space_hostgroup* will be
#     added as hostgroups via "qconf -Ahgrp" and checked that the hostlist field
#     contains all of the hostgroups added from the backslash_setup_hostgroup*
#     files.  All files named backslash_space_fail_hostgroup* will be added
#     via "qconf -Ahgrp" and checked to be sure the operation failed.  Finally,
#     all added hostgroups will be removed.
#
#  RESULT
#     -1 on failure, 0 on success
#
#*******************************
proc qconf_backslash_default_space_check {} {
   global CHECK_ACTUAL_TEST_PATH CHECK_PRODUCT_TYPE 
   global CHECK_USER ts_config

   ts_log_fine "testing qconf default backslash parsing with spaces ..."
   set master_host [resolve_host $ts_config(master_host)]

   # Setup
   set setup_groups ""
   catch { set setup_groups [glob "$CHECK_ACTUAL_TEST_PATH/backslash_setup_hostgroup*"] }
   set required_groups ""
   set ADDED    [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] "(\[@a-zA-Z0-9_-\]+)" "host group"]

   foreach group $setup_groups {
      set output [start_sge_bin "qconf" "-Ahgrp $group" $master_host $CHECK_USER]
      set output [string trim $output]
      ts_log_fine $output
      if { [regexp $ADDED $output match groupname] == 0 } {
         ts_log_severe "error parsing file \"$group\" in qconf_backslash_default_space_check ($output)"
         return
      }
      lappend required_groups $groupname
      ts_log_fine "added host group \"$groupname\""
   }

   set required_groups [lsort $required_groups]

   # Check backslash parsing with spaces
   set space_groups ""
   catch { set space_groups [glob "$CHECK_ACTUAL_TEST_PATH/backslash_space_hostgroup*"] }
   set added_groups ""

   foreach group $space_groups {
      ts_log_fine "parsing host group file: $group"
      set output [start_sge_bin "qconf" "-Ahgrp $group" $master_host $CHECK_USER]
      if { [regexp $ADDED $output match groupname] == 0 } {
         ts_log_severe "error parsing file \"$group\" in qconf_backslash_default_space_check"
         continue
      }

      ts_log_fine "added host group $groupname"
      lappend added_groups $groupname

      # Check that the hostgroup was added correctly
      set output [start_sge_bin "qconf" "-shgrp $groupname" ]

      if { [regexp {hostlist[ \t]+([^\n]+)} $output match hostlist] == 0 } {
         ts_log_severe "error parsing file \"$group\" in qconf_backslash_default_space_check"
         continue
      }

      set hostlist [lsort $hostlist]

      if { $hostlist != $required_groups } {
         ts_log_severe "error parsing file \"$group\" in qconf_backslash_default_space_check"
         continue
      }
   }

   # Check backslash parsing failures
   set space_groups ""
   catch { set space_groups [glob "$CHECK_ACTUAL_TEST_PATH/backslash_space_fail_hostgroup*"] }

   foreach group $space_groups {
      ts_log_fine "parsing host group file: $group"
      start_sge_bin "qconf" "-Ahgrp $group" $master_host $CHECK_USER

      if { $prg_exit_state == 0 } {
         ts_log_severe "allowed bad file \"$group\" in qconf_backslash_default_space_check"
         continue
      }
   }

   # Remove groups
   foreach group "$added_groups $required_groups" {
      start_sge_bin "qconf" "-dhgrp $group"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_backslash_default_comma_check() ******
# 
#  NAME
#     qconf_backslash_default_comma_check -- tests backslash line continuation
#
#  SYNOPSIS
#     qconf_backslash_default_comma_check { } 
#
#  FUNCTION
#     This function tests the parsing of backslash line continuation in files.
#     All files named backslash_comma_userlist* will be added as user lists
#     via "qconf -Au" and checked that the entries field contains root, bin, and
#     sys.  All files named backslash_comma_fail_userlist* will be added via
#     "qconf -Au" and checked to be sure the operation failed.  Finally, all
#     added user lists will be removed.
#
#  RESULT
#     -1 on failure, 0 on success
#
#*******************************
proc qconf_backslash_default_comma_check {} {
   global CHECK_ACTUAL_TEST_PATH CHECK_PRODUCT_TYPE
   global CHECK_USER ts_config

   ts_log_fine "testing qconf default backslash parsing with commas ..."
   set master_host [resolve_host $ts_config(master_host)]

   # Check backslash parsing with commas
   set comma_userlists ""
   catch { set comma_userlists [glob "$CHECK_ACTUAL_TEST_PATH/backslash_comma_userlist*"] }
   set required_userlists [lsort "root bin sys"]

   set ADDED    [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] "(\[@a-zA-Z0-9_-\]+)" "userset"]
   ts_log_fine "added is \"$ADDED\""
   foreach userlist $comma_userlists {
      ts_log_fine "parsing userlist file: $userlist"
      set output [start_sge_bin "qconf" "-Au $userlist" $master_host $CHECK_USER]
      ts_log_fine "output is \"$output\""
      if { [regexp $ADDED $output match userlistname] == 0 } {
         ts_log_severe "error parsing file \"$userlist\" in qconf_backslash_comma_check\n(output: $output)"
         return
      }
      ts_log_fine "added userlist $userlistname"
      # Check that the userlist was added correctly
      set output [start_sge_bin "qconf" "-su $userlistname"]
      start_sge_bin "qconf" "-dul $userlistname"

      if { [regexp {entries[ \t]+([^\n]+)} $output match users] == 0 } {
         ts_log_severe "error parsing file \"$userlist\" in qconf_backslash_comma_check"
         continue
      }

      set users [lsort [join [split $users ", "]]]

      if { $required_userlists != $users } {
         ts_log_severe "error parsing file \"$userlist\" in qconf_backslash_comma_check -- unknown users: $user1, $user2"
      }
   }

   # Check backslash parsing failures with commas
   set comma_userlists ""
   catch { set comma_userlists [glob "$CHECK_ACTUAL_TEST_PATH/backslash_comma_fail_userlist*"] }

   foreach userlist $comma_userlists {
      ts_log_fine "parsing userlist file: $userlist"
      start_sge_bin "qconf" "-Au $userlist" $master_host $CHECK_USER
      
      if { $prg_exit_state == 0 } {
         ts_log_severe "error parsing file \"$userlist\" in qconf_backslash_comma_check"
         continue
      }
   }
}

#                                                             max. column:     |
#****** qconf/qconf_backslash_custom_space_check() ******
# 
#  NAME
#     qconf_backslash_custom_space_check -- tests backslash line continuation
#
#  SYNOPSIS
#     qconf_backslash_custom_space_check { } 
#
#  FUNCTION
#     This function tests the parsing of backslash line continuation in files.
#     All files named backslash_setup_userlist* will be added as user lists
#     via "qconf -Au".  All files named backslash_space_queue* will be
#     added as queues via "qconf -Aq" and checked that the user_lists field
#     contains all of the user lists added from the backslash_setup_userlist*
#     files.  All files named backslash_space_fail_queue* will be added
#     via "qconf -Aq" and checked to be sure the operation failed.  Finally,
#     all added user lists and queues will be removed.
#
#  RESULT
#     -1 on failure, 0 on success
#
#*******************************
proc qconf_backslash_custom_space_check {} {
   global CHECK_ACTUAL_TEST_PATH CHECK_PRODUCT_TYPE
   global CHECK_USER ts_config

   ts_log_fine "testing qconf custom backslash parsing with spaces ..."
   set master_host [resolve_host $ts_config(master_host)]

   # Setup
   set setup_users ""
   catch { set setup_users [glob "$CHECK_ACTUAL_TEST_PATH/backslash_setup_userlist*"] }
   set required_users ""

   set ADDED    [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] "(\[@a-zA-Z0-9_-\]+)" "userset"]


   foreach user $setup_users {
      set output [start_sge_bin "qconf" "-Au $user" $master_host $CHECK_USER]

      if { [regexp $ADDED $output match username] == 0 } {
         ts_log_severe "error parsing file \"$user\" in qconf_backslash_custom_space_check"
         return
      }

      lappend required_users $username
      ts_log_fine "added userlist $username"
   }

   set required_users [lsort $required_users]

   # Check backslash parsing with spaces
   set space_queues ""
   catch { set space_queues [glob "$CHECK_ACTUAL_TEST_PATH/backslash_space_queue*"] }
  
   set ADDED    [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] "(\[@a-zA-Z0-9_-\]+)" "cluster queue"]
 

   foreach queue $space_queues {
      ts_log_fine "parsing queue file: $queue"
      set output [start_sge_bin "qconf" "-Aq $queue" $master_host $CHECK_USER]

      if { [regexp $ADDED $output match queuename] == 0 } {
         ts_log_severe "error parsing file \"$queue\" in qconf_backslash_custom_space_check"
         continue
      }

      ts_log_fine "added queue $queuename"

      # Check that the hostgroup was added correctly
      set output [start_sge_bin "qconf" "-sq $queuename"]
      start_sge_bin "qconf" "-dq $queuename"

      if { [regexp {user_lists[ \t]+([^\n]+)} $output match userlist] == 0 } {
         ts_log_severe "error parsing file \"$queue\" in qconf_backslash_custom_space_check"
         continue
      }

      set userlist [lsort $userlist]

      if { $userlist != $required_users } {
         ts_log_severe "error parsing file \"$queue\" in qconf_backslash_custom_space_check"
      }
   }

   # Check backslash parsing failures
   set space_queues ""
   catch { set space_queues [glob "$CHECK_ACTUAL_TEST_PATH/backslash_space_fail_queue*"] }

   foreach queue $space_queues {
      ts_log_fine "parsing queue file: $queue"
      start_sge_bin "qconf" "-Aq $queue" $master_host $CHECK_USER

      if { $prg_exit_state == 0 } {
         ts_log_severe "allowed bad file \"$queue\" in qconf_backslash_custom_space_check"
         continue
      }
   }

   # Remove userlists
   foreach user $required_users {
      start_sge_bin "qconf" "-dul $user"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_backslash_custom_comma_check() ******
# 
#  NAME
#     qconf_backslash_custom_comma_check -- tests backslash line continuation
#
#  SYNOPSIS
#     qconf_backslash_custom_comma_check { } 
#
#  FUNCTION
#     This function tests the parsing of backslash line continuation in files.
#     All files named backslash_setup_userlist* will be added as user lists
#     via "qconf -Au".  All files named backslash_space_queue* will be
#     added as queues via "qconf -Aq" and checked that the user_lists field
#     contains all of the user lists added from the backslash_setup_userlist*
#     files.  All files named backslash_space_fail_queue* will be added
#     via "qconf -Aq" and checked to be sure the operation failed.  Finally,
#     all added user lists and queues will be removed.
#
#  RESULT
#     -1 on failure, 0 on success
#
#*******************************
proc qconf_backslash_custom_comma_check {} {
   global CHECK_ACTUAL_TEST_PATH CHECK_PRODUCT_TYPE
   global CHECK_USER ts_config

   ts_log_fine "testing qconf custom backslash parsing with commas ..."
   set master_host [resolve_host $ts_config(master_host)]

   # Setup
   set setup_users ""
   catch { set setup_users [glob "$CHECK_ACTUAL_TEST_PATH/backslash_setup_userlist*"] }
   set required_users ""

   set ADDED    [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] "(\[@a-zA-Z0-9_-\]+)" "userset"]

   foreach user $setup_users {
      set output [start_sge_bin "qconf" "-Au $user" $master_host $CHECK_USER]

      if { [regexp $ADDED $output match username] == 0 } {
         ts_log_severe "error parsing file \"$user\" in qconf_backslash_custom_space_check"
         return
      }

      lappend required_users $username
      ts_log_fine "added userlist $username"
   }

   set required_users [lsort $required_users]

   # Check backslash parsing with spaces
   set comma_queues ""
   catch { set comma_queues [glob "$CHECK_ACTUAL_TEST_PATH/backslash_comma_queue*"] }
   set added_queues ""
   
   set ADDED    [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] "(\[@a-zA-Z0-9_-\]+)" "cluster queue"]

   foreach queue $comma_queues {
      ts_log_fine "parsing queue file: $queue"
      set output [start_sge_bin "qconf" "-Aq $queue" $master_host $CHECK_USER]

      if { [regexp $ADDED $output match queuename] == 0 } {
         ts_log_severe "error parsing file \"$queue\" in qconf_backslash_custom_comma_check"
         continue
      }

      ts_log_fine "added queue $queuename"
      lappend added_queues $queuename

      # Check that the hostgroup was added correctly
      set output [start_sge_bin "qconf" "-sq $queuename"]
      start_sge_bin "qconf" "-dq $queuename"

      if { [regexp {user_lists[ \t]+([^\n]+)} $output match userlist] == 0 } {
         ts_log_severe "error parsing file \"$queue\" in qconf_backslash_custom_comma_check"
         continue
      }

      set userlist [lsort [join [split $userlist ", "]]]

      if { $userlist != $required_users } {
         ts_log_severe "error parsing file \"$queue\" in qconf_backslash_custom_comma_check"
      }
   }

   # Check backslash parsing failures
   set comma_queues ""
   catch { set comma_queues [glob "$CHECK_ACTUAL_TEST_PATH/backslash_space_fail_queue*"] }

   foreach queue $comma_queues {
      ts_log_fine "parsing queue file: $queue"
      start_sge_bin "qconf" "-Aq $queue" $master_host $CHECK_USER

      if { $prg_exit_state == 0 } {
         ts_log_severe "allowed bad file \"$queue\" in qconf_backslash_custom_comma_check"
         continue
      }
   }

   # Remove userlists
   foreach user $required_users {
      start_sge_bin "qconf" "-dul $user"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_backslash_space_output_check() ******
# 
#  NAME
#     qconf_backslash_space_output_check -- tests backslash line continuation in
#                                     output
#
#  SYNOPSIS
#     qconf_backslash_space_output_check { } 
#
#  FUNCTION
#     This function tests the outputing of backslash continued lines by qconf.
#     It uses three hostgroup name classes: short, medium, and long.  The short
#     names are just that: short.  The medium name is shorter than a line, but
#     long enough to cause a line wrap in combination with two short names.
#     The long name is longer than a line.  In order to test border cases, the
#     sizes of the names are calulated to produce lines of length 78, 79, 80,
#     and 81 when taken in various combinations.
#
#  RESULT
#     -1 on failure, 0 on success
#
#*******************************
proc qconf_backslash_space_output_check {} {
   global ts_config CHECK_USER env

   ts_log_fine "testing qconf backslash line continuation in output"
   set master_host [resolve_host $ts_config(master_host)]
   set master_arch [resolve_arch $master_host]
   set qconf "$ts_config(product_root)/bin/$master_arch/qconf"

   # Set up failure report
   set failures ""

   set names ""
   # Length > 80
   lappend names "@reallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallylongname1"
   # Length = 47
   lappend names "@thisisareallyreallyreallyreallyreallylongname0"
   # Length = 21
   lappend names "@thisisaveryshortname"
   # Length = 23
   lappend names "@thisisareallyshortname"
   # Length = 24
   lappend names "@thisisareallyshortname2"
   # 0 + offset = 127
   # 1 + 2 + offset + spaces = 78
   # 2 + 3 + 4 + offset + spaces = 79
   # 1 + 3 + offset + spaces = 80
   # 1 + 4 + offset + spaces = 81

   ts_log_fine "adding host groups"

   
   # Add each of the names as a host group
   foreach name $names {
      ts_log_fine "adding host group: $name"
      # localize messages
      set short_name [string range $name 0 99]
      set ADDED [translate $master_host 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER "$master_host*" $short_name "host group"]
      # add by handling vi
      handle_vi_edit "$ts_config(product_root)/bin/$master_arch/qconf" "-ahgrp $name" "" $ADDED
   }

   ts_log_fine "done adding host groups"

   # Store the long names
   set lname [lindex $names 0]
   set mname [lindex $names 1]

   # Remove the long names from the list
   set names [lreplace $names 0 1]

   # Max line size is taken from sge_flatfile.h
   set max_line 80
   # Offset is "hostlist "
   set offset 9
   # Set failure flag
   set failed 0

   # For each relevant permutation of the names list
   for {set mindex 0} {$mindex < 4} {incr mindex} {
      for {set lindex 0} {$lindex < 5} {incr lindex} {
         ts_log_fine "testing permutation $mindex-$lindex"

         set permutation [linsert $names $mindex $mname]
         set permutation [linsert $permutation $lindex $lname]
         # Create a host group with the names list as the host list
         set vi_commands ""
         lappend vi_commands "/hostlist\nwC$permutation[format "%c" 27]"
         set groupname "@qconfbackslash$mindex$lindex"
         # localize messages
         set ADDED [translate $master_host 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER "$master_host*" $groupname "host group"]
         # add by handling vi
         set master_arch [resolve_arch $ts_config(master_host)]
         handle_vi_edit "$ts_config(product_root)/bin/$master_arch/qconf" "-ahgrp $groupname" $vi_commands $ADDED
         
         # Check the output
         # The test suite sets the SGE_SINGLE_LINE variable before every action,
         # so in order to test backslash line continuation, we first have to
         # unset the env var.
         set output [start_remote_prog $master_host $CHECK_USER $qconf "-shgrp $groupname" prg_exit_state 60 0 "" "" 1 1 0 1 0 1]
         # I love TCL.  The next line does the following:
         # 1. Break the output up by lines
         # 2. Remove the first line, the group name
         # 3. Reassemble the output
         # 4. Break the output up by whitespace
         # 5. Remove the first word, "hostlist"
         # What's left is a list containing the names of the host groups and
         # the backslashes as separate list entries.
         set tokens [lrange [split [join [lrange [split [string map {"\r\n" "\n" } $output] "\n"] 1 end]]] 1 end]

         # Calculate the line breaks
         set length 0
         set index 0

         foreach token $tokens {
            # Skip empty tokens
            if {[string length $token] == 0} {
               continue
            }

            set reserve 2

            if {$index >= [llength $permutation]} {
               ts_log_fine "too many tokens: $tokens"
               lappend failures "permutation $mindex-$lindex"
               set failed 1
               break
            } else {
               if {$index == [llength $permutation] - 1} {
                  # If this is the last token, don't reserve space for a line
                  # break
                  set reserve 0
               }
            }

            set name [lindex $permutation $index]
            set strlen [string length $name]

            if {
                (($length + $strlen) >= ($max_line - $offset - $reserve)) &&
                ($length > 0)
            } then {
               if {$token != "\\"} {
                  ts_log_fine "expected backslash: $token"
                  lappend failures "permutation $mindex-$lindex"
                  set failed 1
                  break
               }

               ts_log_fine "matched backslash"

               set length 0
            } else {
               if {$name != $token} {
                  ts_log_fine "expected $name: $token"
                  lappend failures "permutation $mindex-$lindex"
                  set failed 1
                  break
               }

               ts_log_fine "matched token with $strlen characters"

               # Count the space
               if {$length > 0} {
                  incr length
               }

               incr length $strlen
               incr index
            }
         }

         if {($failed != 1) && ([llength $permutation] > $index)} {
            ts_log_fine "expected $name -- too few tokens: $tokens"
            lappend failures "permutation $mindex-$lindex"
            set failed 1
         }

         # Remove the host group
         start_sge_bin "qconf" "-dhgrp $groupname"
      }
   }

   # Remove all host groups
   start_sge_bin "qconf" "-dhgrp $mname"
   start_sge_bin "qconf" "-dhgrp $lname"

   foreach name $names {
      start_sge_bin "qconf" "-dhgrp $name"
   }

   if {$failed} {
      ts_log_severe "error printing hostgroup in qconf_backslash_space_output_check -- failed for $failures"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_backslash_space_output_check() ******
# 
#  NAME
#     qconf_backslash_comma_output_check -- tests backslash line continuation in
#                                     output
#
#  SYNOPSIS
#     qconf_backslash_comma_output_check { } 
#
#  FUNCTION
#     This function tests the outputing of backslash continued lines by qconf.
#     It uses three complex variable name classes: short, medium, and long.  The
#     short names are just that: short.  The medium name is shorter than a line,
#     but long enough to cause a line wrap in combination with two short names.
#     The long name is longer than a line.  In order to test border cases, the
#     sizes of the names are calulated to produce lines of length 78, 79, 80,
#     and 81 when taken in various combinations.
#
#  RESULT
#     -1 on failure, 0 on success
#
#*******************************
proc qconf_backslash_comma_output_check {} {
   global ts_config CHECK_USER env

   set master_host [resolve_host $ts_config(master_host)]
   set master_arch [resolve_arch $master_host]
   set qconf "$ts_config(product_root)/bin/$master_arch/qconf"

   ts_log_fine "testing qconf backslash line continuation in output"

   # Set up failure report
   set failures ""

   set names ""

   ts_log_fine "adding complex variables"

   # Add each of the names as a complex variable
   for {set count 1} {$count <= 5} {incr count} {
      set name "complexvar$count"
      ts_log_fine "adding complex variable: $name"
      # localize messages
      set ADDED [translate $master_host 1 0 0 [sge_macro MSG_SGETEXT_ADDEDTOLIST_SSSS] $CHECK_USER "$master_host*" $name "complex entry"]
      # add by handling vi
      set vi_commands ""
      lappend vi_commands "1Gi$name cv$count RESTRING == YES NO NONE 0\n[format "%c" 27]"
      set master_arch [resolve_arch $ts_config(master_host)]
      handle_vi_edit "$ts_config(product_root)/bin/$master_arch/qconf" "-mc" $vi_commands $ADDED
      lappend names $name
   }

   ts_log_fine "done adding complex variables"

   # Setup desired line lengths
   # 100 + comma + offset = 123
   # 17 + 18 + 20 + commas + offset = 80
   # 37 + 17 + commas + offset = 78
   # 37 + 18 + commas + offset = 79
   # 37 + 20 + commas + offset = 81
   set lines ""
   lappend lines 17
   lappend lines 18
   lappend lines 20
   lappend lines 37
   lappend lines 100

   # Max line size is taken from sge_flatfile.h
   set max_line 80
   # Offset is "complex_values        "
   set offset 22
   # Set failure flag
   set failed 0

   set snames ""
   set count 0

   foreach length $lines {
      set name [lrange $names $count $count]
      set name "${name}="

      set strlen [string length $name]
      set extend [expr $length - $strlen]

      for {set counter 0} {$counter < $extend} {incr counter} {
         set name "${name}0"
      }

      lappend snames $name
      incr count
   }

   # Store the long names
   set mname [lindex $snames 3]
   set lname [lindex $snames 4]

   # Remove the long names from the list
   set snames [lreplace $snames 3 end]

   # localize messages
   set ADDED [translate_macro MSG_SGETEXT_MODIFIEDINLIST_SSSS "*" "*" "*" "*" ]

   # For each relevant permutation of the names list
   for {set mindex 0} {$mindex < 4} {incr mindex} {
      for {set lindex 0} {$lindex < 5} {incr lindex} {
         ts_log_fine "testing permutation $mindex-$lindex"

         set permutation [linsert $snames $mindex $mname]
         set permutation [linsert $permutation $lindex $lname]
         set permuted_names ""

         # Build a comma-separated list
         foreach name $permutation {
            if {$permuted_names == ""} {
               set permuted_names "$name"
            } else {
               set permuted_names "${permuted_names},$name"
            }
         }

         # Added the complex vars to the global host
         start_sge_bin "qconf" "-rattr exechost complex_values \"$permuted_names\" global"

         # Check the output
         # The test suite sets the SGE_SINGLE_LINE variable before every action,
         # so in order to test backslash line continuation, we first have to
         # unset the env var.
         
         
         set output [start_remote_prog $master_host $CHECK_USER $qconf "-se global" prg_exit_state 60 0 "" "" 1 1 0 1 0 1]

         # I love TCL.  The next line does the following:
         # 1. Replace \r\n with \n
         # 2. Break the output up by lines
         # 3. Remove everything except the complex_values lines
         # 4. Reassemble the output
         # 5. Break the output up by whitespace and commas
         # 6. Remove the first word, "complex_values"
         # What's left is a list containing the complex variables and
         # the backslashes as separate list entries.
         set tokens [lrange [split [join [lrange [split [string map {"\r\n" "\n"} $output] "\n"] 2 end-9]] " ,"] 1 end]

         # Calculate the line breaks
         set length 0
         set index 0

         foreach token $tokens {
            # Skip empty tokens
            if {[string length $token] == 0} {
               continue
            }

            # Reserve space for two commas and a line break
            set reserve 4

            if {$index >= [llength $permutation]} {
               ts_log_fine "too many tokens: $tokens"
               lappend failures "permutation $mindex-$lindex"
               set failed 1
               break
            } else {
               if {$index == [llength $permutation] - 1} {
                  # If this is the last token, don't reserve space for a line
                  # break or the last comma.  If this is the only token on the
                  # line, don't reserve space for the first comma either.
                  if {$length == 0} {
                     set reserve 0
                  } else {
                     set reserve 1
                  }
               }
            }

            set name [lindex $permutation $index]
            set strlen [string length $name]

            if {
                (($length + $strlen) > ($max_line - $offset - $reserve)) &&
                ($length > 0)
            } then {
               if {"$token" != "\\"} {
                  ts_log_fine "expected backslash: $token"
                  lappend failures "permutation $mindex-$lindex"
                  set failed 1
                  break
               }

               ts_log_fine "matched backslash"

               set length 0
            } else {
               if {$name != "$token"} {
                  ts_log_fine "expected $name: $token"
                  lappend failures "permutation $mindex-$lindex"
                  set failed 1
                  break
               }

               ts_log_fine "matched token with $strlen characters"

               # Count the comma
               if {$length > 0} {
                  incr length
               }

               incr length $strlen
               incr index
            }
         }

         if {($failed != 1) && ([llength $permutation] > $index)} {
            ts_log_fine "expected $name -- too few tokens: $tokens"
            lappend failures "permutation $mindex-$lindex"
            set failed 1
         }
      }
   }

   # Restore global host
   start_sge_bin "qconf" "-rattr exechost complex_values NONE global"

   # Remove all complex variables
   # localize messages
   set REMOVED [translate $master_host 1 0 0 [sge_macro MSG_SGETEXT_REMOVEDFROMLIST_SSSS] $CHECK_USER "$master_host*" [lrange $names end end] "complex"]
   set vi_commands ""
   lappend vi_commands "/complexvar\n5dd"
   set master_arch [resolve_arch $ts_config(master_host)]
   handle_vi_edit "$ts_config(product_root)/bin/$master_arch/qconf" "-mc" $vi_commands $REMOVED

   if {$failed} {
      ts_log_severe "error printing hostgroup in qconf_backslash_comma_output_check -- failed for $failures"
   }
}

#****** check.60/check_double_output() *****************************************
#  NAME
#     check_double_output() 
#
#  SYNOPSIS
#     check_double_output { string1 string2 } 
#
#  FUNCTION
#     Search in string2 for a sequence of characters that exactly match multiple
#     times the characters in string1.
#
#     The function raises an error if no string was found and if
#     the string was found 2 times.
#
#  INPUTS
#     string1 - string which could be 2 time in string1 
#     string2 - string to search in 
#
#*******************************************************************************
proc check_double_output { string1 string2 } {
   set index [ string last "$string1" "$string2" ]
   if { $index > 0 } {
      set string2 [ string range "$string2" 0 $index ] 
      if { [ string first "$string1" "$string2" ] >= 0 } {
         ts_log_severe "detected issue 1767\n$string1 printed 2 or more times" 
      } 
   } elseif { $index < 0 } {
      ts_log_severe "qconf doesn't reject invalid values"
   }
}

#****** check.60/qconf_issue1767() *********************************************
#  NAME
#     qconf_issue1767()  
#
#  SYNOPSIS
#     qconf_issue1767 { } 
#
#  FUNCTION
#     Tests for Issue 1767 
#
#     Some error messages were printed 2 times because a library function was
#     called which called the ERROR macro and returned an answer_list.
#
#  SEE ALSO
#     check_double_output
#*******************************************************************************
proc qconf_issue1767 {} {
   global ts_config CHECK_USER
   
   set master_host [resolve_host $ts_config(master_host)]

   set tmp_file1 [ get_tmp_file_name ]
   set tmp_file2 [ get_tmp_file_name ]

   #invalid urgency_slots setting
   set REJECTED [translate $master_host 1 0 0 [ sge_macro MSG_PE_REJECTINGURGENCYSLOTS_S ] "invalid" ]
   set result [start_sge_bin "qconf" "-sp mytestpe > $tmp_file1" $master_host $CHECK_USER]
   set result [start_remote_prog $master_host $CHECK_USER "sed" "\"s/min/invalid/\" $tmp_file1 > $tmp_file2"]
   ts_log_fine $result
   set result [start_sge_bin "qconf" "-Mp $tmp_file2" $master_host $CHECK_USER]
   check_double_output $REJECTED $result

   #invalid pe name
   set REJECTED [translate $master_host 1 0 0 [ sge_macro MSG_PE_INVALIDCHARACTERINPE_S ] ".mytestpe" ]
   set result [start_sge_bin "qconf" "-sp mytestpe > $tmp_file1" $master_host $CHECK_USER]
   set result [start_remote_prog $master_host $CHECK_USER "sed" "\"s/mytestpe/.mytestpe/\" $tmp_file1 > $tmp_file2"]
   set result [start_sge_bin "qconf" "-Ap $tmp_file2" $master_host $CHECK_USER]
   check_double_output $REJECTED $result

   #invalid startprocargs 
   set REJECTED [translate $master_host 1 0 0 [ sge_macro  MSG_PE_STARTPROCARGS_SS ] "mytestpe" "unknown variable \"invalid\"" ]
   set result [start_sge_bin "qconf" "-sp mytestpe | sed /start_proc_args/d > $tmp_file1" $master_host $CHECK_USER]
   set result [start_remote_prog $master_host $CHECK_USER "echo" "start_proc_args '\$invalid' >> $tmp_file1"]
   ts_log_fine $result
   set result [start_sge_bin "qconf" "-Mp $tmp_file1" $master_host $CHECK_USER]
   check_double_output $REJECTED $result

   #invalid stopprocargs 
   set REJECTED [translate $master_host 1 0 0 [ sge_macro MSG_PE_STOPPROCARGS_SS ] "mytestpe" "unknown variable \"invalid\"" ]
   set result [start_sge_bin "qconf" "-sp mytestpe | sed /stop_proc_args/d > $tmp_file1" $master_host $CHECK_USER]
   set result [start_remote_prog $master_host $CHECK_USER "echo" "stop_proc_args '\$invalid' >> $tmp_file1"]
   ts_log_fine $result
   set result [start_sge_bin "qconf" "-Mp $tmp_file1" $master_host $CHECK_USER]

   check_double_output $REJECTED $result
}

#                                                             max. column:     |
#****** qconf/qconf_shgrp_tree_check() ******
#
#  NAME
#     qconf_shgrp_tree_check - Display tree like structure of host group 
#
#  SYNOPSIS
#     qconf_shgrp_tree_check { } - Call get_shgrp_tree_error for group "@qconf_test"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host.60/get_hostgroup_tree()
# sge_host.60/get_hostgroup_tree_error()
#*******************************
proc qconf_shgrp_tree_check {} {
   global ts_config env
   global CHECK_USER

   # First do a positive test
   ts_log_fine "Positive test for qconf -shgrp_tree ...\n"
   set result0 [get_hostgroup_tree "@qconf_test" ]

   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -shgrp_tree @qconf_test succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   # next do a negative test
   ts_log_fine "Negative test for qconf -shgrp_tree ...\n"
   set result1 [get_hostgroup_tree "wrong_hostgroup" result $ts_config(master_host) $CHECK_USER 0]

   if { ( $result1 == -1 ) } {
      ts_log_fine "qconf -shgrp_tree wrong_hostgroup succeded"
   } else {
      ts_log_fine "result is $result1"
   }
}
#                                                             max. column:     |
#****** qconf/qconf_shgrp_resolved_check() ******
#
#  NAME
#     qconf_shgrp_resolved_check - Display list of host group 
#
#  SYNOPSIS
#     qconf_shgrp_resolved_check { } - Call "qconf -shgrp_resolved @qconf_test"
#                            Check that the output contains   "$ts_config(master_host)"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host.60/get_hostgroup_resolved()
# sge_host.60/get_hostgroup_resolved_error()
#*******************************
proc qconf_shgrp_resolved_check {} {
   global ts_config env
   global CHECK_USER

   # First do a positive test
   ts_log_fine "Positive test for qconf -shgrp_resolved ...\n"
   set result0 [get_hostgroup_resolved "@qconf_test" ]
   if { ( $result0 == 0 ) } {
      ts_log_fine "qconf -shgrp_resolved @qconf_test  succeded"
   } else {
      ts_log_fine "result is $result0"
   }

   # next do a negative test
   ts_log_fine "Negative test for qconf -shgrp_resolved ...\n"
   set result1 [get_hostgroup_resolved "wrong_hostgroup" result $ts_config(master_host) $CHECK_USER 0]

   if { ( $result1 == -1 ) } {
      ts_log_fine "qconf -shgrp_resolved wrong_hostgroup succeded"
   } else {
      ts_log_fine "result is $result1"
   }
}
#****** qconf/check.60.exp/qconf_modify_hostgroup() ******
#  NAME
#     qconf_modify_hostgroup - Modify host group
#
#  SYNOPSIS
#     qconf_modify_hostgroup { } - Call mod_hostgroup to modify hsot group
#                         from CLI or file
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_processor_list()
#*******************************
proc qconf_modify_hostgroup {} {
   global ts_config env
   global CHECK_USER

   set host [host_conf_get_suited_hosts]

   # Now modify the host list
   ts_log_fine "Modify host group  @qconf_test  from file ...\n"
   set chgar(hostlist) "$host"
   set result1 [mod_hostgroup "@qconf_test" chgar]

   if { ( $result1 == 0 ) } {
      ts_log_fine "qconf -Mhgrp succeded\n"
   } else {
      ts_log_fine "result is $result1"
   }

   # Now do it with a wrong parameter
   ts_log_fine "Modify host group  @qconf_test wrongly from file ...\n"
   set chgar(stuff) "$host"
   set result11 [mod_hostgroup "@qconf_test" chgar 1 $host $CHECK_USER 0]

   if { ( $result11 == -1 ) } {
      ts_log_fine "qconf -Mhgrp failed  correctly\n"
   } else {
      # See IZ 1968 on why this does not fail as expected
      ts_log_fine "result is $result11"
   }

    # Now do it with a wrong parameter again
   ts_log_fine "Modify host group  @qconf_test wrongly from file  again...\n"
   set chgar(hostlist) whatever
   set result11 [mod_hostgroup "@qconf_test" chgar 1 $host $CHECK_USER 0]

   if { ( $result11 == -3 ) } {
      ts_log_fine "qconf -Mhgrp failed  correctly again \n"
   } else {
      # See IZ 1968 on why this does not fail as expected
      ts_log_fine "result is $result11"
   }

   # Now do it from CLI with wrong param again
   set chgar(hostlist) "stuff"
   ts_log_fine "Modify host group  @qconf_test  wrongly from CLI again...\n"
   set result21 [mod_hostgroup "@qconf_test" chgar 0 $host $CHECK_USER 0]

   if { ( $result21 == -3 ) } {
      ts_log_fine "qconf -mhgrp failed  correctly\n"
   } else {
      ts_log_fine "result is $result21"
   }
}

#                                                             max. column:     |
#****** qconf/check.exp.60/qconf_purge_queue() ******
#
#  NAME
#     qconf_purge_queue - Purge queue "qconf_queue.q"
#
#  SYNOPSIS
#     qconf_purge_queue { } - Call add_queue qconf_queue.q $ts_config(master_host) new_queue
#                             Use "qconf -purge queue qname qconf_queue.q"
#                             Then clean up with "qconf -dq qconf_queue.q"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# sge_queue/add_queue()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_purge_queue {} {
   global ts_config
   global CHECK_USER

   # add a test queue
   set host [host_conf_get_suited_hosts]
   set new_queue(load_thresholds) "np_load_avg=10"
   add_queue qconf_queue.q $host new_queue
   set qi [get_queue_instance "qconf_queue.q" $host]
   
   # negative test for the testsuite function - it shall only accept
   # queue instances or queue domains
   set ret [purge_queue "cluster_queue" "prolog" "" "" 0]
   if {$ret != -5} {
      ts_log_severe "purge_queue accepted a cluster queue name"
   }

   # negative test:
   # purge without attribute name
   set ret [purge_queue $qi "" "" "" 0]
   if {$ret != -7} {
      ts_log_severe "purge_queue accepted an empty string as attribute"
   }

   # negative test: qconf -purge from non admin host
   set non_cluster_host [host_conf_get_non_cluster_host]
   if {$non_cluster_host != ""} {
      set ret [purge_queue $qi "load_thresholds" $non_cluster_host "" 0]
      if {$ret == 0} {
         ts_log_severe "qconf -purge from $non_cluster_host (non cluster host) should have failed"
      }
   }

   # Now try load_thresholds for purge on a queue instance
   # set queue instance specific value
   mod_attr "queue" "load_thresholds" "load_avg=20" $qi
   ts_log_fine "Positive test of qconf -purge load_thresholds ...\n"
   set result [purge_queue $qi "load_thresholds"]
   if {$result == 0} {
      ts_log_fine "qconf -purge queue load_thresholds qconf_queue.q succeded"
   } else {
      ts_log_fine "result is $result"
   }

   # negative test - purging it a second time may not work
   set result [purge_queue $qi "load_thresholds" "" "" 0]
   if {$result == -2} {
      ts_log_fine "qconf -purge queue load_thresholds second call failed as expected"
   } else {
      ts_log_severe "qconf -purge for the second time on the same attribute should have failed"
   }

   # Now try load_thresholds for purge on a queue domain
   # set queue domain specific value
   mod_attr "queue" "load_thresholds" "load_avg=20" "qconf_queue.q@@qconf_test"
   ts_log_fine "Positive test of qconf -purge load_thresholds ...\n"
   set result [purge_queue "qconf_queue.q@@qconf_test" "load_thresholds"]
   if {$result == 0} {
      ts_log_fine "qconf -purge queue load_thresholds qconf_queue.q@@qconf_test succeded"
   } else {
      ts_log_fine "result is $result"
   }

   # negative test - purging it a second time may not work
   set result [purge_queue "qconf_queue.q@@qconf_test" "load_thresholds" "" "" 0]
   if {$result == -2} {
      ts_log_fine "qconf -purge queue load_thresholds second call failed as expected"
   } else {
      ts_log_severe "qconf -purge for the second time on the same attribute should have failed"
   }

   # Now purge queue "wrong_queue.q"
   ts_log_fine "Negative test of qconf -purge load_thresholds...\n"
   set result [purge_queue [get_queue_instance "wrong_queue.q" $host] "load_thresholds" "" "" 0]
   if {$result == -1} {
      ts_log_fine "qconf -purge queue load_thresholds wrong_queue.q failed as expected"
   } else {
      ts_log_severe "qconf -purge with a wrong queue didn't fail"
   }

   # Now purge wrong queue domain
   # it doesn't complain about the hostgroup not existing, but about not finding the value
   ts_log_fine "Negative test of qconf -purge load_thresholds...\n"
   set result [purge_queue "qconf_queue.q@@non_existing_hgroup" "load_thresholds" "" "" 0]
   if {$result == -2} {
      ts_log_fine "qconf -purge queue load_thresholds wrong_queue.q failed as expected"
   } else {
      ts_log_severe "qconf -purge with a wrong queue didn't fail"
   }


   # Now delete queue "qconf_queue.q"
   ts_log_fine "Positive test of qconf -dq qconf_queue.q...\n"
   set result [del_queue "qconf_queue.q" $host 1]

   if {$result == 0} {
      ts_log_fine "qconf -dq qconf_queue.q succeded"
   } else {
      ts_log_fine "result is $result"
   }
}

#                                                             max. column:     |
#****** qconf/qconf_de_check() ******
# 
#  NAME
#     qconf_de_check -- ??? 
#
#  SYNOPSIS
#     qconf_de_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_de_check {} {
   global ts_config
   global CHECK_PRODUCT_TYPE CHECK_USER CHECK
   ts_log_fine "testing qconf -de ..."

   # Setup
   set execd [host_conf_get_suited_hosts]
   set arch [resolve_arch $ts_config(master_host)]

   ts_log_fine "using execd host $execd"

   # the tmp_file is automatically removed from testsuite
   set tmp_file [get_tmp_file_name]
   set result [start_sge_bin "qconf" "-se $execd | grep -v load_values | grep -v processors > $tmp_file" $ts_config(master_host) $CHECK_USER]
   if { $prg_exit_state != 0 } {
      ts_log_severe "could not store execd config: $result"
   }
   ts_log_fine "tmp file is: $tmp_file"
   ts_log_fine "doing qconf -dattr hostgroup hostlist $execd @allhosts:"
   set result [start_sge_bin "qconf" "-dattr hostgroup hostlist $execd @allhosts @qconf_test" $ts_config(master_host) $CHECK_USER]
   ts_log_fine $result
 
   if { $prg_exit_state != 0 } {
      ts_log_severe "could not remove host from hostgroup @allhosts: $result"
   }

 
   # Test
   ts_log_fine "doing qconf -de $execd"
   set result [start_sge_bin "qconf" "-de $execd" $ts_config(master_host) $CHECK_USER]
   ts_log_fine $result
   
   set EXEC_HOST_REMOVED [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_REMOVEDFROMLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] [resolve_host $execd 1] "execution host"]

   ts_log_fine "looking for : \"$EXEC_HOST_REMOVED\""
   ts_log_fine "answer was  : \"$result\""

   if { [ string match "*$EXEC_HOST_REMOVED*" $result ] == 0 } {
      ts_log_severe "could not delete live execd: $result\nBug 1269: qconf -de still crashes qmaster"
   }
   ts_log_fine "removed execd $execd from cluster"

   ts_log_fine "doing qconf -Ae $tmp_file"
   set result [start_sge_bin "qconf" "-Ae $tmp_file" $ts_config(master_host) $CHECK_USER]
   ts_log_fine $result

   ts_log_fine "doing qconf -aattr hostgroup hostlist $execd @allhosts"
   set result [start_sge_bin "qconf" "-aattr hostgroup hostlist $execd @allhosts" $ts_config(master_host) $CHECK_USER]
   ts_log_fine $result

   ts_log_fine "added execd $execd to cluster"
}



proc qconf_add_rqs {} {
   global ts_config env rqs_name_fast rqs_name_cli
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   set rqs_name_fast "qconf_rqs_fast"
   set rqs_name_cli "qconf_rqs_cli"
   set rqs_name_invalid "qconf_rqs_invalid"

   set rules {}
   lappend rules "to slots=10"

   # Add resource quota sets fast
   set rqs_charray($rqs_name_fast,limit) $rules
   set result [add_rqs rqs_charray]

   # Add resource quota set from CLI
   unset rqs_charray
   set rqs_charray($rqs_name_cli,limit) $rules
   set result [add_rqs rqs_charray 0]

   # Try to add invalid fast
   set rules {}
   lappend rules "user bla to slots=10"; # user instead of users
   unset rqs_charray
   set rqs_charray($rqs_name_invalid,limit) $rules
   set result [add_rqs rqs_charray 1 "" "" 0]
   if { $result != -2 } {
      ts_log_severe "qconf -Arqs with invalid RQS returned wrong message"
   }
   if { [get_rqs tmp_rqs_charray $rqs_name_invalid  "" "" 0] == 0} {
      ts_log_severe "qconf -Arqs added invalid RQS"
      del_rqs $rqs_name_invalid
   }

   # Try to add invalid CLI
   set result [add_rqs rqs_charray 0 "" "" 0]
   if {[get_rqs tmp_rqs_charray $rqs_name_invalid "" "" 0] == 0} {
      ts_log_severe "qconf -arqs added invalid RQS"
      del_rqs $rqs_name_invalid
   }

   # Try to create resource quota set with insufficient permissions
   # - as non admin user
   # - from non admin host
   set rqs_name "non_admin_user_rqs"
   set rules {}
   lappend rules "to slots=10"

   set ret [add_rqs rqs_charray  1 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER 0]
   if {$ret != -210 && $ret != -214} {
      ts_log_severe "qconf -Arqs should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
      del_rqs $rqs_name
   }

   set non_cluster_host [host_conf_get_non_cluster_host]
   if {$non_cluster_host != ""} {
      set ret [add_rqs rqs_charray  1 $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $ret "admin"]} {
         ts_log_severe "qconf -Arqs should have failed on host $non_cluster_host"
      }
   }

   # Try to add a rqs with invalid filter rule
   # This was CR 6810411, IZ 2899: bad RQS syntax can crash/hang qmaster process
   # we'll use ts_log_warning in the following, as it will crash qmaster if the
   set rules {}
   lappend rules "projects !{testProject,testProject2} queues * hosts * to slots=10"
   if {[info exists rqs_charray]} {
      unset rqs_charray
   }
   set rqs_charray($rqs_name_invalid,limit) $rules
   set result [string trim [add_rqs rqs_charray 1 "" "" 0]]
   if {$result != -4} {
      ts_log_severe "adding a rqs with invalid filter rule should have failed"
   }

   # handle case where qmaster crashed - try to restart qmaster
   # detect gdi error
   if {$result == -120 || $result == -121} {
      ts_log_warning "adding a rqs with invalid filter rule probably crashed qmaster - stopping qconf test"
      # try to repair things
      shutdown_qmaster $ts_config(master_host) [get_qmaster_spool_dir]
      startup_qmaster 0
   }
   # in case the invalid rqs has been created - delete it
   del_rqs $rqs_name_invalid "" "" 0
}

proc qconf_modify_rqs {} {
   global ts_config env rqs_name_fast rqs_name_cli
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   get_rqs_list old_rqs
   set old_rqs_count [llength $old_rqs]

   # Modify resource quota sets fast
   set rules     ""
   lappend rules "users * projects * hosts * pes * queues * to arch=sol-sparc64"
   lappend rules "users * projects * hosts * pes * queues * to arch=sol-amd64"
   lappend rules "users * projects * hosts * pes * to arch=sol-amd64"
   lappend rules "users * projects * hosts * to arch=sol-amd64"
   lappend rules "users * projects * to arch=sol-amd64"
   lappend rules "users * to arch=sol-amd64"
   lappend rules "to arch=sol-amd64"

   set new_rqs_charray($rqs_name_fast,limit) "$rules"
   set result [mod_rqs new_rqs_charray "$rqs_name_fast"]

   get_rqs_list result
   set new_rqs_count [llength $result]

   if { $old_rqs_count != $new_rqs_count } {
      ts_log_severe "modify fast replaced wrongly all resource quota sets"
   }

   # Modify from CLI
   unset new_rqs_charray
   set new_rqs_charray($rqs_name_cli,limit) "$rules"
   set result [mod_rqs new_rqs_charray "$rqs_name_cli" 0]

   get_rqs_list result
   set new_rqs_count [llength $result]

   if { $old_rqs_count != $new_rqs_count } {
      ts_log_severe "modify cli replaced wrongly all resource quota sets"
   }

   # Modify unknown rqs
   unset new_rqs_charray
   set new_rqs_charray("unknown_rqs",limit) "$rules"
   set result [mod_rqs new_rqs_charray "unknown_rqs" 1 "" "" 0]
   if { $result == 0 } {
      ts_log_severe "no error was reported for modifing unknown rqs"
   }

   # try to modify resource quota set with insufficient permissions
   # - as non admin user
   # - from non admin host
   unset new_rqs_charray
   set rules ""
   lappend rules "to slots=10"
   set new_rqs_charray($rqs_name_fast,limit) "$rules"
   set ret [mod_rqs new_rqs_charray "$rqs_name_fast" 1 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER 0]
   if {$ret != -210 && $ret != -212} {
      ts_log_severe "qconf -Mrqs should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   }
   set non_cluster_host [host_conf_get_non_cluster_host]
   if {$non_cluster_host != ""} {
      set ret [mod_rqs new_rqs_charray "$rqs_name_fast" 1 $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $ret "admin"]} {
         ts_log_severe "qconf -Mrqs should have failed on host $non_cluster_host"
      }
   }

   # try to enter duplicate rqs names - they have to be rejected
   set filename [get_tmp_file_name]
   set fd [open $filename "w"]
   puts $fd "{"
   puts $fd "name $rqs_name_fast"
   puts $fd "description first instance of $rqs_name_fast"
   puts $fd "enabled true"
   puts $fd "limit to slots=10"
   puts $fd "}"
   puts $fd "{"
   puts $fd "name $rqs_name_fast"
   puts $fd "description second instance of $rqs_name_fast"
   puts $fd "enabled true"
   puts $fd "limit to slots=20"
   puts $fd "}"
   close $fd
   set result [start_sge_bin "qconf" "-Mrqs $filename" $ts_config(master_host)]

   if {$prg_exit_state == 0} {
      ts_log_severe "qconf should have failed:\n$result"
   } else {
      set expected_message [translate_macro MSG_RQS_REQUEST_DUPLICATE_NAME_S $rqs_name_fast]
      if {[string match "*$expected_message*" $result] == 0} {
         ts_log_severe "qconf should have failed with the error message\n$expected_message\nbut returned\n$result"
      }
   }
}

proc qconf_modifyreplace_rqs {} {
   global ts_config env
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   get_rqs old_rqs_config

   get_rqs_list result
   set old_rqs_count [llength $result]

   set rqs_name "qconf_modifyreplace_rqs"

   set rules     ""
   lappend rules "to arch=sol-amd64"
   set new_rqs_charray($rqs_name,limit) "$rules"

   # Replace from CLI
   set result [mod_rqs new_rqs_charray "" 0]

   get_rqs_list result
   set new_rqs_count [llength $result]

   if { $old_rqs_count == $new_rqs_count } {
      ts_log_severe "modify replace fast doesn't replaced all resource quota sets"
   }

   # Replace resource quota sets fast
   set result [mod_rqs old_rqs_config ""]

   get_rqs_list result
   set new_rqs_count [llength $result]

   if { $old_rqs_count != $new_rqs_count } {
      ts_log_severe "modify replace cli doesn't replaced all resource quota sets"
   }

   # try to replace resource quota set with insufficient permissions
   # - as non admin user
   # - from non admin host
   set ret [mod_rqs old_rqs_config "" 1 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER 0]
   if {$ret != -210 && $ret != -212} {
      ts_log_severe "qconf -Mrqs should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   }
   set non_cluster_host [host_conf_get_non_cluster_host]
   if {$non_cluster_host != ""} {
      set ret [mod_rqs old_rqs_config "" 1 $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $ret "admin"]} {
         ts_log_severe "qconf -Mrqs should have failed on host $non_cluster_host"
      }
   }
}

proc qconf_remove_rqs {} {
   global ts_config env rqs_name_fast rqs_name_cli
   global CHECK_FIRST_FOREIGN_SYSTEM_USER

   # try to delete resource quota set with insufficient permissions
   # - as non admin user
   # - from non admin host
   set ret [del_rqs $rqs_name_fast "" $CHECK_FIRST_FOREIGN_SYSTEM_USER 0]
   if {$ret != -210 && $ret != -214} {
      ts_log_severe "qconf -drqs should have failed for user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   }
   set non_cluster_host [host_conf_get_non_cluster_host]
   if {$non_cluster_host != ""} {
      set ret [del_rqs $rqs_name_fast $non_cluster_host "" 0]
      if {![check_for_non_cluster_host_error $ret "admin"]} {
         ts_log_severe "qconf -drqs should have failed on host $non_cluster_host"
      }
   }

   # delete rqs the first time, should be OK 
   ts_log_fine "deleting resource quota set \"$rqs_name_fast\""
   del_rqs $rqs_name_fast
   ts_log_fine "deleting resource quota set \"$rqs_name_cli\""
   del_rqs $rqs_name_cli

   # delete rqs the second time, should be not OK
   ts_log_fine "deleting resource quota set \"$rqs_name_fast\" the second time"
   set result [del_rqs $rqs_name_fast "" "" 0]
   if {$result == 0} {
      ts_log_severe "qconf -drqs shows no error for invalid rule set"
   }
}

proc qconf_dynamic_limit {} {
   global ts_config env

   set rqs_name "dynamic_rqs"

   set rules {}
   lappend rules "hosts {*} to slots=\$num_proc*2"

   # Add resource quota sets with dynamic limit
   set rqs_charray($rqs_name,limit) $rules
   set result [add_rqs rqs_charray]

   # Try to add invalid dynamic limit (1)
   set rules ""
   lappend rules "hosts * to slots=\$num_proc*2"

   unset rqs_charray
   set rqs_charray($rqs_name,limit) "$rules"
   set ret [mod_rqs rqs_charray "$rqs_name" 1 "" "" 0]
   if { $ret == 0 } {
      ts_log_severe "invalid dynamic limit was accepted (1)"
   }

   # Try to add invalid dynamic limit (2)
   set rules ""
   lappend rules "hosts {*} to slots=\$arch*2"

   unset rqs_charray
   set rqs_charray($rqs_name,limit) "$rules"
   set ret [mod_rqs rqs_charray "$rqs_name" 1 "" "" 0]
   if { $ret == 0 } {
      ts_log_severe "invalid dynamic limit was accepted (2)"
   }

   del_rqs $rqs_name
}

proc qconf_rqs_Xattr {} {
   global ts_config CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER

   # setup two resource quota sets
   set rqs_name1 "qconf_rqs_Xattr1"
   set rqs_name2 "qconf_rqs_Xattr2"
   set object_name "resource_quota"
   set rules {}
   lappend rules "name rule_1 users $CHECK_USER to slots=0"
   lappend rules "name rule_2 users $CHECK_FIRST_FOREIGN_SYSTEM_USER to slots=0"
   lappend rules "name rule_3 to slots=0"

   set rqs_charray($rqs_name1,description) "none"
   set rqs_charray($rqs_name1,enabled) "false"
   set rqs_charray($rqs_name1,limit) $rules
   set rqs_charray($rqs_name2,description) "none"
   set rqs_charray($rqs_name2,enabled) "false"
   set rqs_charray($rqs_name2,limit) $rules

   set result [add_rqs rqs_charray]

   # test mattr for name
   set result [mod_attr "$object_name" "name" "bla" "$rqs_name1" 0 "" "" 0]
   if { $result != -2 } {
      ts_log_severe "qconf -mattr $object_name name bla $rqs_name1 should have failed"
   }

   # test mattr for enabled
   set result [mod_attr "$object_name" "enabled" "true" "$rqs_name1" 0]
   get_rqs modified_rqs
   if { $modified_rqs($rqs_name1,enabled) == "FALSE" || $modified_rqs($rqs_name2,enabled) == "TRUE" } {
      ts_log_severe "qconf -mattr $object_name enabled true $rqs_name1 failed"
   }

   # test mattr for description
   set descr "qconf xattr test description"
   set result [mod_attr "$object_name" "description" "\"$descr\"" "$rqs_name2" 0]
   get_rqs modified_rqs
   if { $modified_rqs($rqs_name1,description) == $descr || $modified_rqs($rqs_name2,description) != $descr } {
      ts_log_severe "qconf -mattr $object_name description \"$descr\" $rqs_name1 failed"
   }

   # test mattr for limit
   set result [mod_attr "$object_name" "limit" "slots=100" "$rqs_name2/3" 0]
   get_rqs modified_rqs
   set org_value [lindex $rqs_charray($rqs_name2,limit) 2]
   set new_value [lindex $modified_rqs($rqs_name2,limit) 2]
   if { $org_value == $new_value } {
      ts_log_severe "qconf -mattr $object_name limit slots=3 $rqs_name1/3 failed"
   }

   # test aattr for limit
   set result [add_attr "$object_name" "limit" "arch=bla" "$rqs_name1/rule_2" 0]
   get_rqs modified_rqs
   set org_value [lindex $rqs_charray($rqs_name1,limit) 1]
   set new_value [lindex $modified_rqs($rqs_name1,limit) 1]
   if { $org_value == $new_value } {
      ts_log_severe "qconf -aattr $object_name limit arch=bla $rqs_name1/rule_2 failed"
   }

   # rattr/dattr are not rqs specific and need to be tested generally for all objects
   
   # cleanup
   del_rqs $rqs_name1
   del_rqs $rqs_name2
}

proc qconf_rqs_rattr_qmaster_dump {} {
   global ts_config env

   set object_name "resource_quota"

   set rqs_name "qconf_rqs_Xattr_qmaster_dump"
   set rules {}
   lappend rules "hosts {*} to slots=\$num_proc*2"

   set rqs_charray($rqs_name,enabled) "true"
   set rqs_charray($rqs_name,limit) $rules

   set result [add_rqs rqs_charray]

   set job_options "-o /dev/null -j y -t 1:10 $ts_config(product_root)/examples/jobs/sleeper.sh 10000"
   set job_id [submit_job "$job_options"]
   trigger_scheduling
   wait_for_jobstart $job_id "leeper" 20

   after 2000
   set result [mod_attr "$object_name" "limit" "slots=\$num_proc" "$rqs_name" 0 "" "" 0]
   after 2000
   if {[is_qmaster_alive $ts_config(master_host) [get_qmaster_spool_dir]] == 0} {
      ts_log_severe "modattr with invalid rule name crashed qmaster"
      startup_qmaster 0
   }

   delete_job $job_id

   del_rqs $rqs_name
}

#****** clients/qconf/qconf_help() **************************************************
#  NAME
#     qconf_help() -- Checks return value of qconf -help and qconf with no option 
#
#  SYNOPSIS
#     qconf_help { } 
#
#  FUNCTION
#      Performs a qconf -help and checks if the return value is 0. 
#      Saves the help text and checks if the help text is contained 
#      in "qconf with no option" output. This can additionally contain 
#      an error message and it is written on stderr (but this is not 
#      checked). 
#
#*******************************************************************************
proc qconf_help {} {
   test_help_and_usage "qconf"
}


############# qconf/qconf_issue_2383() *********************************************
#  NAME
#     issue_2383() -- test qconf -mc with incorrect complex
#
#  SYNOPSIS
#     issue_2383 { }
#
#  FUNCTION
#     Test adding incorrect complex with qconf -mc
#
#     The complex is defined as
#     newone            new      STRING      ==    NO          NO         NONE
#     so it is missing the urgency value. It is a negative test.
#     The install should report message MSG_CENTRY_NULL_URGENCY
#
#*******************************************************************************
proc qconf_issue_2383 {} {
   global ts_config
    
   # Create a faulty complex. note that there is NO urgency value

   set wrong_complex(newone) "new STRING  ==  NO  NO NONE "   
   # Call set_complex with null_urgency set to "1", the last var
   set result [set_complex wrong_complex 0]
      
   # check that we get the correct error message MSG_CENTRY_NULL_URGENCY
   if {$result != -6 } {
      ts_log_severe "qconf -mc test for IZ 2383 failed"
   }
}


############# qconf/qconf_issue_2445() *********************************************
#  NAME
#     issue_2383() -- test qconf -mq with wrong shell path
#
#  SYNOPSIS
#     issue_2445 { }
#
#  FUNCTION
#     Test adding wrong shell path with qconf -mq
#
#     The shell path is defined as
#     shell  NONE
#     so it is wrong the urgency value. It is a negative test.
#     The install should report message MSG_CQUEUE_UNKNOWNSHELL_S
#
#     We also test that a job submitted with -S NONE goes into Eqw state.
#*******************************************************************************
proc qconf_issue_2445 {} {
   global ts_config
  
   # Try to modify shell setting to "NONE" via "qconf -mq test_queue.q"
   # set shell to "NONE"
   set change_array(shell) "NONE"
   set result [mod_queue test_queue.q "" change_array 1 "" "" 0]
   
   # check that we get the correct error message MSG_CENTRY_NULL_URGENCY
   if {$result == 0} {
      ts_log_severe "qconf -mq test for IZ 2445 failed.\nExpected qconf to fail, but got result:\n$result"
   } else {
      ts_log_fine "qconf -mq test for IZ 2445 passed"
   }

   # Submit now job with -S NONE. Check that it goes in Error state.
   # With Cluster Scheduler 9.0.0 we have shell_start_mode unix_behavior as default
   # where the shell is read out of the script => submit the job as binary job
   set job_opts "-o /dev/null -e /dev/null"
   if {[is_version_in_range "9.0.0"]} {
      append job_opts " -b y"
   }
   append job_opts " -S NONE"
   set sleep_t 30
   set t_cmd "$ts_config(product_root)/examples/jobs/sleeper.sh $sleep_t"
   set t_qsub_arguments "$job_opts $t_cmd"
   set job_id [submit_job $t_qsub_arguments]

   wait_for_job_state $job_id "Eqw" 60
   
   set E_state_ok 0
   set job_state [get_job_state $job_id]
   if {[string compare $job_state "Eqw"] == 0} {
      set E_state_ok 1
   }

   if {$E_state_ok != 1} {
      ts_log_config  "Job did not switch into E state in qsub -S NONE scenario. E_state_ok was $E_state_ok, job_state was $job_state."
   } else {
      ts_log_fine  "qsub -S NONE negative test for IZ 2445 passed"
   }
}


############# qconf/qconf_Aconf() *********************************************
#  NAME
#     qconf_Aconf() 
#
#  SYNOPSIS
#     qconf_Aconf{} - tests if modification of already existing config is
#                     possible through qconf -Aconf
#
#  FUNCTION
#     Test adding already existing configuration through qconf -Aconf
#
#     After submitting a configuration from a file, we expect a warning
#     message that the current configuration already exists. Furthermore, 
#     this configuration should not be modified
#
#*******************************************************************************
proc qconf_Aconf {} {
   global ts_config
  
   # run qconf -Aconf with an already existing configuration
   set result [string trim [start_sge_bin "qconf" "-Aconf $ts_config(master_host)"]]

   # check that we get the correct error message MSG_ANSWER_CONFIGXALREADYEXISTS_S
   set expected_message "[translate_macro MSG_ANSWER_CONFIGXALREADYEXISTS_S "*"]"
   if {![string match $expected_message $result]} {
      ts_log_severe "qconf_Aconf test failed.\nExpected qconf to fail with \"$expected_message\", but got result:\n\"$result\""
   } else {
      ts_log_fine "qconf_Aconf test passed"
   }
}

proc qconf_issue_2960 {} {
   global CHECK_USER

   ts_log_fine "test writing into not writeable TMPDIR value ..."
   set error_text ""
   set host [host_conf_get_suited_hosts]
   set user $CHECK_USER
   set tmp_dir  [get_tmp_directory_name $host "default" "tmp" 1]
   remote_file_mkdir $host $tmp_dir

   set my_env(EDITOR) "echo"
   set my_env(TMPDIR) $tmp_dir
   ts_log_fine "tmp dir is set to: $tmp_dir"
   set output [start_sge_bin "qconf" "-mc" $host $user prg_exit_state 15 "" "bin" output_lines my_env]
   ts_log_fine $output

   # Check if output contains correct tmpdir path
   if {[string match "*$tmp_dir*" $output]} {
      ts_log_fine "found directory output in qconf -mc command, good!"
      foreach perm "{555 1} {000 1} {755 0}" {
         set perms [lindex $perm 0]
         set expected_exit_state [lindex $perm 1] 
         # Now set permissions not writeable
         set output [start_remote_prog $host $user "chmod" "$perms $tmp_dir"]

         # This call should produce timeout if issue is present
         set output [start_sge_bin "qconf" "-mc" $host $user prg_exit_state 10 "" "bin" output_lines my_env]
         ts_log_fine $output
         ts_log_fine "exit status = $prg_exit_state"
         if {$prg_exit_state != $expected_exit_state} {
            append error_text "exit status (=$prg_exit_state) should be $expected_exit_state for dir permissions=$perms.\n"
         }
      }
   } else {
      append error_text "output of qconf -mc (env EDITOR=$my_env(EDITOR), env TMPDIR=$my_env(TMPDIR)\n"
      append error_text "does not contain tmp directory path ($tmp_dir)!\n\n"
   }

   remote_delete_directory $host $tmp_dir
   if {$error_text != ""} {
      ts_log_severe $error_text
   }
}

#****** qconf/qconf_delete_admin_user() *************************************
#  NAME
#     qconf_delete_admin_user() -- check deleting of manager / operator
#
#  SYNOPSIS
#     qconf_delete_admin_user { } 
#
#  FUNCTION
#     Check if deleting a manager or operator fails for the user
#     root and for the admin user.
#     This was CR 6684465 / IZ 3053
#*******************************************************************************
proc qconf_delete_admin_user {} {
   global ts_config CHECK_USER

   set commands {}
   lappend commands "-dm root"
   lappend commands "-dm $CHECK_USER"
   lappend commands "-do root"
   lappend commands "-do $CHECK_USER"

   foreach command $commands {
      ts_log_fine "testing $command"

      set user [lindex $command 1]
      set msg [translate_macro MSG_SGETEXT_MAY_NOT_REMOVE_USER_FROM_LIST_SS $user "*"]

      # start the command
      set output [string trim [start_sge_bin "qconf" $command]]

      # expect the command to have failed, and expect correct error message
      # we use ts_log_warning here, as qmaster is unusable if admin user is deleted
      if {$prg_exit_state != 1} {
         ts_log_warning "qconf $command should have failed"
         break
      }
      if {![string match $msg $output]} {
         ts_log_warning "qconf $command should have printed\n$msg\nbut got instead\n$output"
         break
      }
   }
}

############# qconf/qconf_ke() *********************************************
#  NAME
#     qconf_ke() 
#
#  SYNOPSIS
#     qconf_ke{} - tests that failure to send execd kill signal results
#                  in a correct exit code.
#
#  FUNCTION
#     try sending a kill execd to a daemon that is already shutdown.
#
#     After submitting the kill command we receive an error message stating
#     that Cluster Scheduler (Grid Engine) failed to send kill command to execd, and we expect the 
#     exit code to be 1
#
#*******************************************************************************
proc qconf_ke {} {
   global ts_config CHECK_USER
  
   # run qconf -ke to initially kill the execd
   set host [host_conf_get_suited_hosts]
   set result [start_sge_bin "qconf" "-ke $host"]

   wait_for_queue_state "all.q@$host" "au" 60

   set master_arch [resolve_arch $ts_config(master_host)]
   set qconf "$ts_config(product_root)/bin/$master_arch/qconf"
   set output [start_remote_prog $ts_config(master_host) $CHECK_USER $qconf "-ke $host" prg_exit_state 60 0 "" "" 1 1 0 1 0 1]
   
   set expected_message [translate_macro MSG_COM_NONOTIFICATION_SSS "failed" "*" "*"]

   if {$prg_exit_state == "0"} {
      ts_log_severe "qconf_ke test failed.\nExpected qconf to return exit code other than 0, but got result:\n$prg_exit_state"
   } else {
      ts_log_fine "qconf_ke test successful"
   }

   #restart the execd on host that was shutdown
   startup_execd $host
}
