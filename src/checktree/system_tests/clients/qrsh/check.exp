#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
#  Portions of this software are Copyright (c) 2011 Univa Corporation.
#  Portions of this software are Copyright (c) 2023-2024 HPC-Gridware GmbH
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name
global check_category
global check_description
global check_needs
global check_functions
global check_root_access_needs

# define test's name and run level descriptions
set check_name            "qrsh"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_description(0)    "checking qrsh to one exec host (master)"
set check_description(200)  "checking qrsh to all exec hosts"

# define test's dependencies
set check_needs           "init_core_system"
set check_root_access_needs  "yes"

# setup and cleanup functions
set check_setup_level_function "qrsh_setup"
set check_cleanup_level_function "qrsh_cleanup"

# define test's procedure order
set check_functions {}
lappend check_functions "qrsh_function"              ;# is a job executed?
lappend check_functions "qrsh_h"                     ;# test -h option
lappend check_functions "qrsh_hold_jid"              ;# test -hold_jid option
lappend check_functions "qrsh_alltoall"              ;# qrsh from all hosts to all hosts
lappend check_functions "qrsh_starter_method"        ;# does the starter method work for qrsh?
lappend check_functions "qrsh_accounting"            ;# accounting and online usage (sgeee)
lappend check_functions "qrsh_suspend"               ;# suspend
lappend check_functions "qrsh_delete"                ;# delete
lappend check_functions "qrsh_terminate"             ;# test terminate method
lappend check_functions "qrsh_qsub_gid"              ;# qsub gid set correctly?
lappend check_functions "qrsh_batch"                 ;# run qrsh in batch mode
lappend check_functions "qrsh_limits"                ;# limits (e.g. cpu) passed correctly
lappend check_functions "qrsh_env"                   ;# test the -v VAR=val and -v VAR options
lappend check_functions "qrsh_reservation"           ;# test the -R y option
lappend check_functions "qrsh_sigterm_running_job"   ;# test CTRL-C for running job
lappend check_functions "qrsh_sigterm_pending_job"   ;# test CTRL-C for pending job
lappend check_functions "qrsh_notify"                ;# check signal handling

lappend check_functions "qrsh_wd"                    ;# test the -wd <dir>/-cwd options
lappend check_functions "qrsh_w_v_test"
lappend check_functions "qrsh_pty_yes_redirect"
lappend check_functions "qrsh_pty_yes_line_breaks"   ;# test if NL gets converted to CR NL
lappend check_functions "qrsh_forward_stdin"         ;# test if stdin forward works via <

# -------- local test procedures -----------------------------------------------
proc qrsh_setup {} {
   global ts_config CHECK_ACT_LEVEL
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_FIRST_FOREIGN_SYSTEM_GROUP
   global qrsh_hostlist qrsh_submithost
   global QSUB_GID_USER QSUB_GID_GROUPS

   # setup hosts
   set qrsh_submithost $ts_config(master_host)
   switch -exact $CHECK_ACT_LEVEL {
      0 {
         # get one suited host for testing
         set qrsh_hostlist [host_conf_get_suited_hosts]
      }
      200 {
         # get one suited host from each architecture for testing
         set qrsh_hostlist $ts_config(unique_arch_nodes)
      }
   }

   ts_log_fine "using submit host  $qrsh_submithost"
   ts_log_fine "using exec host(s) $qrsh_hostlist"

   # setup some user info
   set QSUB_GID_USER   $CHECK_FIRST_FOREIGN_SYSTEM_USER
   set QSUB_GID_GROUPS $CHECK_FIRST_FOREIGN_SYSTEM_GROUP
}

proc qrsh_cleanup {} {
   global qrsh_hostlist qrsh_submithost
   global QSUB_GID_USER QSUB_GID_GROUPS

   foreach var "qrsh_hostlist qrsh_submithost QSUB_GID_USER QSUB_GID_GROUPS" {
      if {[info exists $var]} {
         unset $var
      }
   }

   delete_all_jobs
   wait_for_end_of_all_jobs
}

# -------- check functions -----------------------------------------------------
proc qrsh_function {} {
   global ts_config CHECK_USER
   global qrsh_hostlist qrsh_submithost

   ts_log_fine "qrsh functional test"
   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-l hostname=$host echo qrsh successfully started"]
      set sp_id [lindex $qrsh_id 1]

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "qrsh successfully started" {
            ts_log_fine "qrsh to host $host ok"
            exp_continue
         }
         -i $sp_id "_exit_status_:(*)*\n" {
            ts_log_fine "got exit status from script:\n$expect_out(buffer)"
         }
         -i $sp_id default {
            ts_log_severe "qrsh to host $host failed"
         }
      }

      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs
}

#                                                             max. column:     |
#****** qrsh/wait_for_has_been_submitted() ******
#
#  NAME
#     wait_for_has_been_submitted -- Waits for the output "has been submitted"
#                                    and parses the job ID.
#
#  SYNOPSIS
#     wait_for_has_been_submitted {sp_id}
#
#  FUNCTION
#     Waits on the spawn id (returend by open_remote_spawn_process)
#     for the output "Your job JOB_ID has been submitted" and parses
#     the JOB_ID.
#
#  INPUTS
#     sp_id - the spawn id returned by open_remote_spawn_process.
#
#  RESULT
#     The ID of the job
#*******************************
proc wait_for_has_been_submitted {sp_id} {
   global ts_config
   set job_id 0
   set remote_host ""

   set HAS_BEEN_SUBMITTED [translate_macro MSG_JOB_SUBMITJOB_US "*" "*"]
   set ESTABLISHING_SESSION [translate_macro MSG_QSH_ESTABLISHINGREMOTESESSIONTO_SS "*" "*"]
   set timeout 60
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id timeout {
         ts_log_severe "timeout waiting for qrsh -notify to be submitted"
      }
      -i $sp_id eof {
         ts_log_severe "eof waiting for qrsh -notify to be submitted"
      }
      -i $sp_id $HAS_BEEN_SUBMITTED {
         set job_id [lindex $expect_out(0,string) 2]
         exp_continue
      }
      -i $sp_id $ESTABLISHING_SESSION {
         set remote_host [lindex $expect_out(0,string) 5]
      }
   }
   if {$job_id != 0 && $remote_host != ""} {
      ts_log_fine "qrsh job $job_id correctly submitted to remote host $remote_host"
   }
   return $job_id
}

#                                                             max. column:     |
#****** qrsh/wait_for_running() ******
#
#  NAME
#     wait_for_running -- Waits for the output "running"
#
#  SYNOPSIS
#     wait_for_running {sp_id}
#
#  FUNCTION
#     Waits on the spawn id (returend by open_remote_spawn_process)
#     for the output "running".
#
#  INPUTS
#     sp_id - the spawn id returned by open_remote_spawn_process.
#*******************************
proc wait_for_running {sp_id} {
   set timeout 60
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id timeout {
         ts_log_severe "Got no output from job! Job seems not to be in running state"
      }
      -i $sp_id eof {
         ts_log_severe "eof waiting for output from job"
      }
      -i $sp_id "running"  {
         ts_log_fine "job script started "
      }
   }
}

#                                                             max. column:     |
#****** qrsh/wait_for_Signal() ******
#
#  NAME
#     wait_for_Signal -- Waits for the output "Signal"
#
#  SYNOPSIS
#     wait_for_Signal {sp_id signal_name sent_signal}
#
#  FUNCTION
#     Waits on the spawn id (returend by open_remote_spawn_process)
#     for the output "Signal".
#
#  INPUTS
#     sp_id - The spawn id returned by open_remote_spawn_process.
#     signal_name - The name of the signal that the execds should send to
#                   the script according to the "-notify" signal mapping.
#                   Can be "USR1" or "USR2".
#     sent_signal - The name of the signal that was sent to the execd.
#                   Can be "KILL" or "STOP".
#*******************************
proc wait_for_Signal {sp_id signal_name sent_signal} {
   set timeout 30
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id eof {
         ts_log_severe "eof waiting for output from job"
      }
      -i $sp_id timeout {
         ts_log_severe "Job did't catch signal!"
      }
      -i $sp_id "Signal" {
         ts_log_fine "Successful transfer of the signal SIG$sent_signal -> SIG$signal_name."
      }
   }
}

#                                                             max. column:     |
#****** qrsh/do_qrsh_notify_test() ******
#
#  NAME
#     do_qrsh_notify_test -- The actual qrsh notify test procedure
#
#  SYNOPSIS
#     do_qrsh_notify_test {signal_name}
#
#  FUNCTION
#     Does the actual qrsh notify test. Starts a script per qrsh that
#     catches signals and prints the signal name. Then deletes or
#     suspends the job, waits for the job script to print the signal's
#     name and compares it with the expected signal.
#
#  INPUTS
#     signal_name - The name of the signal that the job script should receive.
#                   Can be "USR1" or "USR2"
#*******************************
proc do_qrsh_notify_test {signal_name} {
   global CHECK_ACTUAL_TEST_PATH
   global ts_config CHECK_USER
   global qrsh_hostlist qrsh_submithost

   set arch [resolve_arch $qrsh_submithost]
   set qrsh_command "$ts_config(product_root)/bin/$arch/qrsh"
   set qrsh_job     "$CHECK_ACTUAL_TEST_PATH/signalhandler.sh $signal_name"

   foreach host $qrsh_hostlist {
      set qrsh_options "-notify -nostdin -verbose -l h=$host"
      # start qrsh with bash script which is waiting for a signal
      ts_log_fine "starting $qrsh_command $qrsh_options $qrsh_job   \
                   on host $qrsh_submithost as user $CHECK_USER"

      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER \
                   $qrsh_command "$qrsh_options $qrsh_job"]
      set sp_id [lindex $qrsh_id 1]

      # scan the verbose output of qrsh for job id

      set job_id [wait_for_has_been_submitted $sp_id]
      if {$job_id == 0} {
         close_spawn_process $qrsh_id
         continue
      }

      # wait for first output of the remote script
      wait_for_running $sp_id

      # send signal SIGKILL or SIGSTOP
      if {$signal_name == "USR2"} {
         delete_job $job_id
         # wait for the output "Signal"
         wait_for_Signal $sp_id "$signal_name" "KILL"
      } else {
         suspend_job $job_id
         # wait for the output "Signal"
         wait_for_Signal $sp_id "$signal_name" "STOP"
      }

      close_spawn_process $qrsh_id
   }
   wait_for_end_of_all_jobs
}

#                                                             max. column:     |
#****** qrsh/qrsh_notify() ******
#
#  NAME
#     qrsh_notify -- Checks if started with -notify the signal forwarding is
#                    is correct.
#
#  SYNOPSIS
#     qrsh_notify { }
#
#  FUNCTION
#     Starts a shell scripts which are waiting for SIGUSR(1|2) signal.
#     Sends a SIGKILL and SIGSTOP signal to the scripts. Because of
#     the -notify option these signals can be caught as SIGUSR1 and
#     SIGUSR2 signals.
#*******************************
proc qrsh_notify {} {
   do_qrsh_notify_test "USR2"
   do_qrsh_notify_test "USR1"
}

proc qrsh_h {} {
   global ts_config CHECK_USER
   global qrsh_submithost

   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs $ts_config(product_root)/examples/jobs/sleeper.sh 30"
   set job_id [submit_job $arguments]
   delete_job $job_id  ;# now we know the last job id

   incr job_id 1       ;# job id of next job !
   set arch [resolve_arch $qrsh_submithost]
   set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-h echo qrsh successfully started"]
   set sp_id [lindex $qrsh_id 1]

   trigger_scheduling
   wait_for_jobpending $job_id "echo" 60

   trigger_scheduling
   set run_result [get_standard_job_info $job_id]
   foreach line $run_result {
      set tmp_job_id [lindex $line 0]
      set tmp_job_state [lindex $line 4]
      ts_log_fine "job id: $tmp_job_id, job state: $tmp_job_state"
   }

   if {$tmp_job_state != "hqw"} {
      ts_log_severe "qrsh -h job is not in pending state"
   }

   trigger_scheduling

   set timeout 15
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "qrsh successfully started" {
         ts_log_severe "qrsh -h failed"
      }
      -i $sp_id default {
         ts_log_fine "qrsh -h timeout for hold state ok, now releasing job $job_id"
      }
   }

   release_job $job_id
   trigger_scheduling

   set timeout 60
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "qrsh successfully started" {
         ts_log_fine "qrsh -h ok"
      }
      -i $sp_id default {
         ts_log_severe "qrsh -h failed for job $job_id"
      }
   }

   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "_exit_status_:(*)*\n" {
         ts_log_fine "got exit status from script:\n$expect_out(buffer)"
      }
      -i $sp_id default {
         ts_log_severe "got timeout for job $job_id"
      }
   }

   close_spawn_process $qrsh_id

   wait_for_end_of_all_jobs
}

proc qrsh_hold_jid {} {
   global ts_config CHECK_USER
   global qrsh_submithost

   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs $ts_config(product_root)/examples/jobs/sleeper.sh 6000"
   set hold_job_id [submit_job $arguments]
   set job_id [expr $hold_job_id + 1]
   set arch [resolve_arch $qrsh_submithost]
   set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-hold_jid $hold_job_id echo qrsh successfully started"]
   set sp_id [lindex $qrsh_id 1]

   trigger_scheduling
   wait_for_jobpending $job_id "echo" 60

   trigger_scheduling
   set run_result [get_standard_job_info $job_id]
   foreach line $run_result {
      set tmp_job_id [lindex $line 0]
      set tmp_job_state [ lindex $line 4 ]
      ts_log_fine "job id: $tmp_job_id, job state: $tmp_job_state"
   }

   if {$tmp_job_state != "hqw"} {
      ts_log_severe "qrsh -hold_jid job is not in pending state"
   }

   trigger_scheduling

   set timeout 15
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "qrsh successfully started" {
         ts_log_severe "qrsh -hold_jid failed"
      }
      -i $sp_id default {
         ts_log_fine "qrsh -hold_jid timeout for hold state ok, now deleting job $hold_job_id"
      }
   }

   delete_job $hold_job_id 1
   trigger_scheduling

   set timeout 60
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "qrsh successfully started" {
         ts_log_fine "qrsh -hold_jid ok"
      }
      -i $sp_id default {
         ts_log_severe "qrsh -hold_jid failed for job $job_id"
      }
   }

   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "_exit_status_:(*)*\n" {
         ts_log_fine "got exit status from script:\n$expect_out(buffer)"
      }
      -i $sp_id default {
         ts_log_severe "qrsh -hold_jid failed for job $job_id"
      }
   }

   close_spawn_process $qrsh_id
   wait_for_end_of_all_jobs
}

proc qrsh_alltoall {} {
   global ts_config
   global CHECK_USER
   global qrsh_hostlist

   foreach source $qrsh_hostlist {
      set source_arch [resolve_arch $source]
      foreach dest $qrsh_hostlist {
         set qrsh_id [open_remote_spawn_process "$source" $CHECK_USER "$ts_config(product_root)/bin/$source_arch/qrsh" "-l hostname=$dest echo qrsh successfully started"]
         set sp_id [lindex $qrsh_id 1]
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            }
            -i $sp_id eof {
               ts_log_severe "open_remote_spawn_process closed connection (eof)"
            }
            -i $sp_id "qrsh successfully started" {
               ts_log_fine "qrsh from host $source to host $dest ok"
               exp_continue
            }
            -i $sp_id "_exit_status_:(*)*\n" {
               ts_log_fine "got exit status from script:\n$expect_out(buffer)"
            }
            -i $sp_id default {
               ts_log_severe "qrsh from host $source to host $dest failed"
            }
         }

         close_spawn_process $qrsh_id
      }
   }

   wait_for_end_of_all_jobs
}

proc qrsh_starter_method {} {
   global ts_config CHECK_ACTUAL_TEST_PATH
   global CHECK_USER
   global qrsh_hostlist qrsh_submithost

   # set starter method
   set change_array(starter_method) "$CHECK_ACTUAL_TEST_PATH/starter.sh"
   mod_queue all.q "" change_array

   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-l hostname=$host echo qrsh successfully started"]
      set sp_id [lindex $qrsh_id 1]

      set timeout 60
      set starter_method 0
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "starter method started" {
            set starter_method 1
            exp_continue
         }
         -i $sp_id "qrsh successfully started" {
            if {$starter_method == 0} {
               ts_log_severe "qrsh job started without starter_method on host $host"
            } else {
               ts_log_fine "qrsh to host $host ok"
            }
            exp_continue
         }
         -i $sp_id "_exit_status_:(*)*\n" {
            ts_log_fine "got exit status from script:\n$expect_out(buffer)"
         }
         -i $sp_id default {
            ts_log_severe "qrsh to host $host failed"
         }
      }

      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs

   # unset starter method
   set change_array(starter_method) "none"
   mod_queue "all.q" "" change_array
}

proc qrsh_accounting {} {
   global ts_config CHECK_PRODUCT_TYPE
   global CHECK_USER
   global qrsh_hostlist qrsh_submithost

   set INTERACTIVE_JOB [translate_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_S "*"]
   set INTERACTIVE_JOB_DUMMY [translate_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_S "__JOBID__"]
   set job_id_start [string first "__JOBID__" $INTERACTIVE_JOB_DUMMY]

   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {

      set job_run_time 120

      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-verbose -nostdin -l hostname=$host $ts_config(product_root)/examples/jobs/worker.sh $job_run_time"]

      set state startup
      set job_id ""
      set sp_id [lindex $qrsh_id 1]

      while {[string compare $state exit] != 0} {
         set timeout 80
         expect {
            -i $sp_id full_buffer {
               ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               set state exit
            }
            -i $sp_id eof {
               ts_log_severe "open_remote_spawn_process closed connection (eof)"
               set state exit
            }
            -i $sp_id timeout {
               # now (after 80s) the job should be running
               if {[string compare $state running]} {
                  ts_log_severe "qrsh to host $host failed"
                  set state exit
               } else {
                  # in sgeee mode, we can check the online usage
                  if {$CHECK_PRODUCT_TYPE == "sgeee"} {
                     if {$job_id == ""} {
                        ts_log_severe "unknown job_id for qrsh job on host $host"
                     } else {
                        if {[info exists job_info]} {
                           unset job_info
                        }
                        if {[get_extended_job_info $job_id] == 1} {
                           if {$job_info(cpu) < 10} {
                              ts_log_config "online usage probably does not work on $host"
                           }
                        }
                     }
                  }
               }
            }
            -i $sp_id $INTERACTIVE_JOB {
               ts_log_finer "jobstart: \"$expect_out(0,string)\""
               set job_id [string range $expect_out(0,string) $job_id_start end]
               set space_start [string first " " $job_id]
               set job_id [string range $job_id 0 $space_start]
               set job_id [string trim $job_id]
               ts_log_fine "job id is: \"$job_id\""
               set state scheduled
            }
            -i $sp_id "Forking" { ;# "Forking" printout is from worker job (utilbin/work.c)
               set state running
            }
            -i $sp_id "_exit_status_" {   ;# _exit_status_ is from open_remote_spawn_process - generated script
               if {[string compare $state running]} {
                  ts_log_severe "qrsh to host $host failed"
               }
               set state exit
            }
         }
      }

      close_spawn_process $qrsh_id

      # wait for accounting file to be flushed (esp. for 6.0) and NFS
      ts_log_fine "now waiting for end of job ..."
      wait_for_end_of_all_jobs

      ts_log_fine "now check accounting of job ..."
      if {$job_id != ""} {
         if {[get_qacct $job_id qacct_info $ts_config(master_host)] == 0} {
            set cpu [expr $qacct_info(ru_utime) + $qacct_info(ru_stime)]
            # the machine might be busy, so we might not get the cpu for the whole runtime
            set my_allowed_cpu_value [expr $job_run_time - 10.0]

            ts_log_fine "cpu entry: $cpu should be >= $my_allowed_cpu_value"
            if {$cpu < $my_allowed_cpu_value} {
               set help_text     "cpu entry \"$cpu\" in accounting seems to be wrong for job $job_id on host $host which\n"
               append help_text "is a worker with runtime = $job_run_time\nI expected at least a runtime of\n"
               append help_text "$my_allowed_cpu_value seconds!\n"
               append help_text "This might happen on virtual hosts which report wrong wallclock time!\n"
               ts_log_info $help_text
            }

            if {$cpu < 30} {
               ts_log_severe "cpu entry \"$cpu\" in accounting seems to be wrong for job $job_id on host $host"
            }

            if {$CHECK_PRODUCT_TYPE == "sgeee"} {
               # compute absolute diffence between cpu and ru_utime + ru_stime
               set difference [expr $cpu - $qacct_info(cpu)]
               set difference [expr $difference * $difference]
               if {$difference > 2} {
                  ts_log_severe "accounting: cpu($qacct_info(cpu)) is not the sum of ru_utime and ru_stime ($cpu) for job $job_id on host $host"
               }
            }
         }
      }
   }
}

proc qrsh_suspend {} {
   global ts_config
   global CHECK_USER
   global qrsh_hostlist qrsh_submithost

   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      set running_states [host_get_running_states $host]
      set suspended_states [host_get_suspended_states $host]

      # start qrsh job (shell script that outputs its pid)
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-l hostname=$host $ts_config(testsuite_root_dir)/scripts/work_pid.sh 60"]

      # evaluate pid and JOB_ID
      set sp_id [ lindex $qrsh_id 1 ]

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            close_spawn_process $qrsh_id
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "my pid is *\n" {
            set job_pid [lindex $expect_out(0,string) 3]
            set job_id [lindex $expect_out(0,string) 7]
            ts_log_fine "job has pid $job_pid and job id $job_id"
         }
         -i $sp_id timeout {
            close_spawn_process $qrsh_id
            ts_log_severe "qrsh to host $host failed"
         }
         -i $sp_id "_exit_status_" {
            close_spawn_process $qrsh_id
            ts_log_severe "qrsh to host $host failed"
         }
         -i $sp_id eof {
            close_spawn_process $qrsh_id
            ts_log_severe "open_remote_spawn_process closed connection (eof)"
         }
      }

      # continue only, if job is running correctly
      if {[info exists job_pid] && [info exists job_id]} {
         # check process status (should be sleeping or running)
         get_ps_info $job_pid $host

         if {$ps_info($job_pid,error) != 0} {
            close_spawn_process $qrsh_id
            ts_log_severe "cannot get info about process $job_pid on host $host"
            continue
         }
         ts_log_fine "job should be running"
         ts_log_fine $ps_info($job_pid,index_names)
         ts_log_fine $ps_info($job_pid,string)
         if {[string first $ps_info($job_pid,state) $running_states] == -1} {
            close_spawn_process $qrsh_id
            ts_log_severe "process $job_pid on host $host is in unexpected state $ps_info($job_pid,state)\nps output:\n$ps_info($job_pid,index_names)\n$ps_info($job_pid,string)"
            continue
         }

         # suspend job
         suspend_job $job_id
         after 10000
         # process status should be suspended
         get_ps_info $job_pid $host
         if {$ps_info($job_pid,error) != 0} {
            ts_log_severe "cannot get info about process $job_pid on host $host"
            close_spawn_process $qrsh_id
            continue
         }
         ts_log_fine "job should be suspended"
         ts_log_fine $ps_info($job_pid,index_names)
         ts_log_fine $ps_info($job_pid,string)
         if {[string first $ps_info($job_pid,state) $suspended_states] == -1} {
            ts_log_severe "process $job_pid on host $host is in unexpected state $ps_info($job_pid,state)"
            close_spawn_process $qrsh_id
            continue
         }

         # unsuspend job
         unsuspend_job $job_id
         after 10000
         # process status should be sleeping or running
         get_ps_info $job_pid $host
         if {$ps_info($job_pid,error) != 0} {
            ts_log_severe "cannot get info about process $job_pid on host $host"
            close_spawn_process $qrsh_id
            continue
         }
         ts_log_fine "job should be running"
         ts_log_fine $ps_info($job_pid,index_names)
         ts_log_fine $ps_info($job_pid,string)
         if {[string first $ps_info($job_pid,state) $running_states] == -1} {
            ts_log_severe "process $job_pid on host $host is in unexpected state $ps_info($job_pid,state)"
            close_spawn_process $qrsh_id
            continue
         }
      }

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            ts_log_severe "timeout waiting for qrsh to host $host to finish"
         }
         -i $sp_id eof {
            ts_log_severe "open_remote_spawn_process closed connection (eof)"
         }
         -i $sp_id "_exit_status_" {
         }
      }

      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs
}

proc qrsh_delete {} {
   global ts_config CHECK_ACTUAL_TEST_PATH
   global CHECK_USER
   global qrsh_hostlist qrsh_submithost

   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      # start qrsh job (shell script that outputs its pid)
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-l hostname=$host $CHECK_ACTUAL_TEST_PATH/sleep_pid.sh 120"]
      set sp_id [ lindex $qrsh_id 1 ]

      # evaluate pid and JOB_ID
      set timeout 60
      set error 0
      expect {
         -i $sp_id full_buffer {
            close_spawn_process $qrsh_id
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            set error 1
         }
         -i $sp_id "my pid is*" {
            ts_log_fine "got pid of job!"
            set job_pid [lindex $expect_out(0,string) 3]
            set job_id [lindex $expect_out(0,string) 7]
         }
         -i $sp_id timeout {
            close_spawn_process $qrsh_id
            ts_log_severe "qrsh to host $host failed - timeout"
            set error 1
         }
         -i $sp_id eof {
            close_spawn_process $qrsh_id
            ts_log_severe "qrsh to host $host failed - eof"
            set error 1
         }

      }

      if {$error == 0} {
         if {[info exists job_pid] && [info exists job_id]} {
            # qdel
            ts_log_fine "now deleting job $job_id ..."
            delete_job $job_id 1

            # check if shell script is still running
            get_ps_info $job_pid $host
            if {$ps_info($job_pid,error) == 0} {
               ts_log_severe "process of deleted job $job_pid on host $host is still running"
            } else {
               ts_log_fine "job is gone - ok !"
            }
         }
      }

      close_spawn_process $qrsh_id 1

      set q_state [get_queue_state "all.q@${host}"]
      if {[string first "E" $q_state] >= 0} {
         ts_log_severe "queue all.q@${host} goes to state \"$q_state\" after job deletion"
         delete_all_jobs ;# this will remove the E state
      }
   }

   wait_for_end_of_all_jobs
}

proc qrsh_terminate {} {
   global ts_config CHECK_USER CHECK_ACTUAL_TEST_PATH
   global qrsh_hostlist qrsh_submithost

   set terminate_out_file [get_tmp_file_name]

   # set terminate method
   set change_array(terminate_method) "$CHECK_ACTUAL_TEST_PATH/terminate.sh \$job_id \$job_pid $terminate_out_file"
   mod_queue "all.q" "" change_array

   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      # start qrsh job (shell script that outputs its pid)
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-l hostname=$host $CHECK_ACTUAL_TEST_PATH/sleep_pid.sh 120"]

      # evaluate pid and JOB_ID
      set sp_id [lindex $qrsh_id 1]
      set error 0
      set timeout 60
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            set error 1
         }
         -i $sp_id timeout {
            ts_log_severe "qrsh to host $host failed - timeout"
            set error 1
         }
         -i $sp_id eof {
            ts_log_severe "qrsh to host $host failed - eof"
            set error 1
         }
         -i $sp_id "my pid is*" {
            set job_pid [lindex $expect_out(0,string) 3]
            set job_id [lindex $expect_out(0,string) 7]
         }
      }

      if {$error == 1} {
         close_spawn_process $qrsh_id
         continue
      }

      if {[info exists job_pid] && [info exists job_id]} {
         get_ps_info $job_pid $host
         # qdel
         delete_job $job_id

         for {set i 0} {$i < 60} {incr i} {
            after 1000
            start_remote_prog $host $CHECK_USER ls $terminate_out_file exit_code
            if {$exit_code == 0} {
               ts_log_fine "terminate method has been started"
               break
            } else {
               ts_log_fine "waiting for terminate method"
            }
         }

         # wait for terminate method to finish
         # TODO: (CR) Not sure - if possible we should not write tests which expects
         #            tasks after timeouts. What happens if NFS is slow?
         after 2000
         ts_log_fine "waiting for termination and file $terminate_out_file"

         # check contents of terminate.out
         set line [start_remote_prog $host $CHECK_USER cat $terminate_out_file exit_code]
         if {$exit_code != 0} {
            ts_log_severe "error reading from terminate method output file on host $host"
         } elseif {[scan $line "job_id=%d job_pid=%d" t_job_id t_job_pid] != 2} {
            ts_log_severe "error reading from terminate method output file on host $host"
         } elseif {$job_pid != $t_job_pid} {
            ts_log_severe "wrong job_pid passed to terminate method for job $job_id on host $host, should be $job_pid but is $t_job_pid"
         }
         # check if shell script is still running
         get_ps_info $job_pid $host
         if {$ps_info($job_pid,error) == 0} {
            ts_log_severe "process of deleted job $job_pid on host $host is still running"
         }
      }

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            ts_log_severe "timeout waiting for qrsh to host $host to finish"
         }
         -i $sp_id eof {
            ts_log_severe "open_remote_spawn_process closed connection (eof)"
         }
         -i $sp_id "_exit_status_" {
         }
      }

      close_spawn_process $qrsh_id
   }

   # reset terminate method
   set change_array(terminate_method) "NONE"
   mod_queue "all.q" "" change_array

   wait_for_end_of_all_jobs
}

proc check_qsub_gid_output {output check_group} {
   # output if BSD's id is different from other archs. There egid entry might exist.
   set start_egid [string first "egid=" $output]
   set start_gid [string first "gid=" $output]
   if {$start_egid != -1} {
      set start $start_egid
   } else {
      set start $start_gid
   }
   set substring [string range $output $start end]

   set group [string trim [string range $substring [string first "(" $substring] [string first ")" $substring]] "()"]

   ts_log_fine "process was executed under user group $group"

   if {[string compare $group $check_group] == 0} {
      return 1
   } else {
      return 0
   }
}

proc qrsh_qsub_gid {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_PROTOCOL_DIR
   global QSUB_GID_USER QSUB_GID_GROUPS
   global qrsh_hostlist qrsh_submithost

   if {![host_has_newgrp $qrsh_submithost 0]} {
      ts_log_config "cannot run this test:\nqrsh submithost $qrsh_submithost doesn't have the newgrp command"
      return
   }

   set USING_FOR     [translate_macro MSG_CONF_USING_SS "*USE_QSUB_GID=true*" "*"]
   set FINISHED_JOBS [translate_macro MSG_CONF_USING_SS "*finished_jobs*" "*"]

   set submit_host_arch [resolve_arch $qrsh_submithost]

   foreach host $qrsh_hostlist {
      ts_log_fine "using host $host"
      # dump commandfile to file
      set f [open $CHECK_PROTOCOL_DIR/qrsh.sh w]
      set id_command [host_get_id_a_command $host]
      puts $f "$ts_config(product_root)/bin/$submit_host_arch/qrsh -l hostname=$host $id_command"
      close $f

      file attributes "$CHECK_PROTOCOL_DIR/qrsh.sh" -permissions 00755
      wait_for_remote_file $host $QSUB_GID_USER $CHECK_PROTOCOL_DIR/qrsh.sh

      # call qsub_gid.sh, gid must be primary gid
      set output [start_remote_prog $qrsh_submithost $QSUB_GID_USER "$CHECK_ACTUAL_TEST_PATH/qsub_gid.sh" "[lindex $QSUB_GID_GROUPS 1] $CHECK_PROTOCOL_DIR/qrsh.sh"]
      set group [lindex $QSUB_GID_GROUPS 0]
      if {[check_qsub_gid_output $output $group] == 0} {
         ts_log_severe "qrsh job on host $host was executed with wrong gid, should be $group, output of qrsh job was $output"
      }

      # set parameter USE_QSUB_GID
      get_config config $host
      get_config saved_config $host
      if {[info exists config(execd_params)]} {
         set execd_params $config(execd_params)
      } else {
         set execd_params ""
      }

      if {$execd_params == ""} {
         set config(execd_params) "USE_QSUB_GID=true"
      } else {
         set config(execd_params) "$execd_params,USE_QSUB_GID=true"
      }
      set_config_and_propagate config $host

      # call qsub_gid.sh, gid must be secondary gid
      set output [start_remote_prog $qrsh_submithost $QSUB_GID_USER "$CHECK_ACTUAL_TEST_PATH/qsub_gid.sh" "[lindex $QSUB_GID_GROUPS 1] $CHECK_PROTOCOL_DIR/qrsh.sh"]
      set group [lindex $QSUB_GID_GROUPS 1]
      if {[check_qsub_gid_output $output $group] == 0} {
         ts_log_severe "qrsh job on host $host was executed with wrong gid, should be $group, output of qrsh job was $output"
      }

      # unset USE_QSUB_GID
      unset config
      set config(execd_params) $execd_params
      reset_config_and_propagate saved_config $host
   }

   wait_for_end_of_all_jobs
}

proc qrsh_batch {} {
   global ts_config
   global CHECK_USER
   global qrsh_hostlist qrsh_submithost

   ts_log_fine "check qrsh in immediate and batch mode (-now yes / no)"
   set COULD_NOT_BE_SCHEDULED [translate_macro MSG_QSH_REQUESTCANTBESCHEDULEDTRYLATER_S "*" ]
   set HAS_BEEN_SUBMITTED  [translate_macro MSG_JOB_SUBMITJOB_US "*" "*"]
   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      set queue [get_queue_instance "all.q" $host]
      # disable queue
      disable_queue $queue
      ts_log_fine "queue should be disabled now ..."
      # start qrsh - must be rejected
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-q $queue -N immediate echo blahblah"]
      set sp_id [lindex $qrsh_id 1]

      # evaluate pid and JOB_ID
      set timeout 60
      set error 1
      log_user 1
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "blahblah" {
            ts_log_severe "qrsh -now yes ran despite no resources free on host $host"
         }
         -i $sp_id $COULD_NOT_BE_SCHEDULED {
            ts_log_fine "qrsh aborted correctly"
            set error 0
         }
         -i $sp_id timeout {
            ts_log_severe "timeout waiting for qrsh -now yes on host $host to fail due to lack of resources"
         }
         -i $sp_id eof {
            ts_log_severe "qrsh -now yes failed without error message on host $host"
         }
      }
      close_spawn_process $qrsh_id

      if {$error} {
         ts_log_severe "skipping test on host $host"
         enable_queue [get_queue_instance "all.q" $host]
         continue
      }

      # start qrsh -now no
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-verbose -q $queue -now no -N batch echo blahblah"]
      # must be in pending jobs
      set sp_id [lindex $qrsh_id 1]

      set timeout 60
      log_user 1
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            set error 1
         }
         -i $sp_id timeout {
            ts_log_severe "timeout waiting for qrsh -now no to be submitted to host $host"
            set error 1
         }
         -i $sp_id eof {
            ts_log_severe "eof waiting for qrsh -now no to be submitted to host $host"
            set error 1
         }
         -i $sp_id $HAS_BEEN_SUBMITTED {
            set job_id [lindex $expect_out(0,string) 2]
            ts_log_fine "qrsh job $job_id correctly submitted"
            set error 0
         }
      }
      if {$error} {
         ts_log_severe "skipping test on host $host"
         close_spawn_process $qrsh_id
         enable_queue $queue
         continue
      }

      if {[get_extended_job_info $job_id] == 0} {
         ts_log_severe "no job info for job $job_id - skipping test on host $host"
         delete_job $job_id 1
         close_spawn_process $qrsh_id
         enable_queue $queue
         continue
      }

      if {$job_info(state) != "qw"} {
         ts_log_severe "state of job is $job_info(state), should be qw, skipping test on host $host"
         delete_job $job_id 1
         close_spawn_process $qrsh_id
         enable_queue $queue
         continue
      }

      # enable queue, trigger scheduling
      ts_log_fine "now enable the queue ..."
      enable_queue $queue
      trigger_scheduling

      # job must be scheduled
      set timeout 60
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "blahblah" {
            ts_log_fine "got qrsh job output as expected (blahblah)!"
         }
         -i $sp_id $COULD_NOT_BE_SCHEDULED {
            ts_log_severe "message \"could not be scheduled\" should not occur with batch jobs"
         }
         -i $sp_id timeout {
            ts_log_severe "timeout waiting for qrsh to be scheduled to host $host"
         }
         -i $sp_id eof {
            ts_log_severe "qrsh exited without executing command on host $host"
         }
      }

      # now wait for shell termination
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            ts_log_severe "timeout waiting for exit_status on host $host"
         }
         -i $sp_id eof {
            ts_log_severe "got eof on host $host"
         }
         -i $sp_id "_exit_status_:(*)*\n" {
            ts_log_fine "got exit status from script:\n$expect_out(buffer)"
         }
      }
      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs
}

proc qrsh_limits {} {
   global ts_config CHECK_ACTUAL_TEST_PATH CHECK_USER
   global qrsh_hostlist qrsh_submithost

   ts_log_fine "check if limits are propagated to qrsh jobs"
   set limit_in 10
   set arch [resolve_arch $qrsh_submithost]
   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-l hostname=$host -l h_cpu=$limit_in $CHECK_ACTUAL_TEST_PATH/ulimit.sh"]
      set sp_id [lindex $qrsh_id 1]

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            ts_log_severe "qrsh to host $host failed"
         }
         -i $sp_id eof {
            ts_log_severe "qrsh to host $host failed"
         }
         -i $sp_id "CPU limit is *\n" {
            set limit_out [lindex $expect_out(0,string) 3]
            ts_log_fine "qrsh to host $host ok, CPU limit is $limit_out s"

            if {$limit_out != $limit_in} {
               ts_log_severe "limit on host $host not correctly set"
            }
         }
      }

      expect {
         -i $sp_id full_buffer {
            ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id timeout {
            ts_log_severe "timeout error while waiting for exit_status on host $host"
         }
         -i $sp_id eof {
            ts_log_severe "got eof on host $host"
         }
         -i $sp_id "_exit_status_:(*)*\n" {
            ts_log_fine "got exit status from script:\n$expect_out(buffer)"
         }
      }
      close_spawn_process $qrsh_id
   }

   wait_for_end_of_all_jobs 30
}

proc qrsh_reservation {} {
   global ts_config
   global qrsh_submithost

   set msg "blahblah"
   set output [start_sge_bin "qrsh" "-R y echo $msg" $qrsh_submithost]
   if {$prg_exit_state != 0 || ![qrsh_output_contains $output $msg]} {
      ts_log_severe "qrsh -R y failed - see Issue: 1306:\n$output"
   }

   delete_all_jobs
   wait_for_end_of_all_jobs
}

proc qrsh_env {} {
   global ts_config CHECK_USER
   global qrsh_submithost

   ts_log_fine "check if environment variables are set correctly"

   # Set a dummy env var
   set inherited_value "ThIsIsAtEsT"
   set explicit_value "tHiSiSoNlYaTeSt"
   set my_env(QRSH_ENV_TEST_DUMMY) $inherited_value

   # Test
   set arch [resolve_arch $qrsh_submithost]
   set qrsh_bin "$ts_config(product_root)/bin/$arch/qrsh"
   set output [start_remote_prog $qrsh_submithost $CHECK_USER $qrsh_bin "-v QRSH_ENV_TEST_DUMMY 'echo \$QRSH_ENV_TEST_DUMMY'" prg_exit_state 60 0 "" my_env]
   if {![qrsh_output_contains $output $inherited_value]} {
      set error_text "qrsh did not inherit test environment variable: $inherited_value != $output\n"
      append error_text "Bug 1255: qrsh does not properly pass along environment variables"
      ts_log_severe $error_text
   }

   set output [start_remote_prog $qrsh_submithost $CHECK_USER $qrsh_bin "-v QRSH_ENV_TEST_DUMMY=$explicit_value 'echo \$QRSH_ENV_TEST_DUMMY'" prg_exit_state 60 0 "" my_env]
   if {![qrsh_output_contains $output $explicit_value]} {
      set error_text "qrsh did not inherit test environment variable: $explicit_value != $output\n"
      append error_text "Bug 1255: qrsh does not properly pass along environment variables"
      ts_log_severe $error_text
   }

   delete_all_jobs
   wait_for_end_of_all_jobs
}

#****** qrsh/qrsh_limits() ******
#
#  NAME
#     qrsh_limits -- send CTRL-C to running job
#
#  SYNOPSIS
#     qrsh_limits { }
#
#  FUNCTION
#     Test if Issue 1639 exists
#
#  SEE ALSO
#     qrsh_sigterm_pending_job
#*******************************

proc qrsh_sigterm_running_job {} {
   global ts_config
   global CHECK_USER
   global qrsh_submithost

   # start qrsh
   set arch [resolve_arch $qrsh_submithost]
   set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER "$ts_config(product_root)/bin/$arch/qrsh" "\"echo started; sleep 3600\""]
   set sp_id [lindex $qrsh_id 1]

   # job must be scheduled
   set timeout 30
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id -- "started" {
         ts_log_fine "qrsh job started as expected!"
      }
      -i $sp_id timeout {
         ts_log_severe "timeout waiting for qrsh to be scheduled"
      }
   }

   # now terminate the connection - this will send a CTRL-C to the qrsh
   close_spawn_process $qrsh_id
   wait_for_end_of_all_jobs 60

   set output [start_sge_bin qstat "-s pr"]
   if {$prg_exit_state == 0} {
      if {$output == ""} {
         ts_log_fine "no further jobs in system"
      } else {
         ts_log_severe "CTRL-C for running qrsh job does not delete job - issue 1639:\n$output"
      }
   } else {
      ts_log_severe "error executing qstat -s pr:\n$output"
   }

   delete_all_jobs
   wait_for_end_of_all_jobs
}

#****** qrsh/qrsh_limits() ******
#
#  NAME
#     qrsh_limits -- send CTRL-C to pending job
#
#  SYNOPSIS
#     qrsh_limits { }
#
#  FUNCTION
#     Test if Issue 1639 exists
#
#  SEE ALSO
#     qrsh_sigterm_running_job
#*******************************
proc qrsh_sigterm_pending_job {} {
   global ts_config
   global CHECK_USER
   global qrsh_submithost

   set arch [resolve_arch $qrsh_submithost]
   # start qrsh
   set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER "$ts_config(product_root)/bin/$arch/qrsh" "-now n -l arch=bla sleep 3600"]
   set sp_id [lindex $qrsh_id 1]

   set timer 10
   while {[get_job_info -1] == 0} {
      if {$timer == 0} {
         ts_log_severe "error submitting qrsh job"
         break
      }
      after 1000
      incr timer -1
   }

   # now terminate the connection - this will send a CTRL-C to the qrsh
   close_spawn_process $qrsh_id
   wait_for_end_of_all_jobs 15

   set output [start_sge_bin qstat "-s pr"]
   if {$prg_exit_state == 0} {
      if {$output == ""} {
         ts_log_fine "no further jobs in system"
      } else {
         ts_log_severe "CTRL-C for pending qrsh job does not delete job - issue 1639:\n$output"
      }
   } else {
      ts_log_severe "error executing qstat -s pr:\n$output"
   }

   delete_all_jobs
   wait_for_end_of_all_jobs
}

#                                                             max. column:     |
#****** qrsh/replace_automount_prefix() ***************************************
#
#  NAME
#     replace_automount_prefix -- Replaces the automount prefix of a path with
#                                 the replacement defined in
#                                 $SGE_ROOT/$SGE_CELL/common/sge_aliases
#
#  SYNOPSIS
#     replace_automount_prefix path
#
#  FUNCTION
#     Checks if the passed path has one of the automount prefixes defined in
#     the $SGE_ROOT/$SGE_CELL/common/sge_aliases file. If yes, it replaces
#     the automount prefix with the replacement defined in the sge_aliases file.
#
#  INPUTS
#     path  - The path whose automount prefix is to be replaced
#
#  RETURN VALUE
#     The path with replaced automount prefix
#
#  EXAMPLE
#     sge_aliases:
#     /tmp_mnt/   *   *  /
#
#
#     set path_in "/tmp_mnt/this/is/my/path"
#     set path_out [replace_automount_prefix $path_in]
#     ts_log_fine "path_out = $path_out"
#
#     path_out = /this/is/my/path
#
#  SEE ALSO
#
#***************************************************************************
#
proc replace_automount_prefix {path} {
   global ts_config
   set do_loop 1

   # Open sge_aliases file
   set error [catch {
      set f [open $ts_config(product_root)/$ts_config(cell)/common/sge_aliases "r"]
      } output]

   if {$error != 0} {
      ts_log_severe "error opening $ts_config(product_root)/$ts_config(cell)/"
                    "common/sge_aliases file:\n$output"
   } else {
      while {[gets $f line] >= 0 && $do_loop == 1} {
         # Search first non-blank character, if it is a '#' then skip line,
         # else read it's contents and compare with the passed path.
         set tmp_list [split $line] ;# Need to split explicitely, a ");" in the
                                    ;# sge_aliases would stop the lindex otherwise
         if {[string index [lindex $tmp_list 0] 0] != "#"} {
            # Here it's no comment line
            set prefix [lindex $line 0]
            set replace [lindex $line 3]
            if {[string compare -length [string length $prefix] $prefix $path] == 0} {
               # The passed path has this automounter prefix - strip it!
               set path [string range $path [string length $prefix] end]
               # Add the replacement for the automount prefix to beginning of path
               set path "$replace$path"

               # The automounter prefix is stripped from the path ->
               # exit for loop and while loop
               set do_loop 0
            }
         }
      }
      close $f
   }
   return $path
}

#****** qrsh/qrsh_wd() ******
#
#  NAME
#     qrsh_wd -- test if -wd/-cwd work
#
#  SYNOPSIS
#     qrsh_wd { }
#
#*******************************
proc qrsh_wd {} {
   global ts_config
   global qrsh_submithost qrsh_hostlist

   # Set a directory
   set wdir "/tmp"
   set cwdir [pwd]

   foreach host $qrsh_hostlist {
      # Test1 -wd $wdir
      set output [start_sge_bin "qrsh" "-l h=$host -wd $wdir pwd"]
      set output [replace_automount_prefix $output]
      if {![qrsh_output_contains $output $wdir]} {
         set error_text "qrsh did not set the correct working dir: $wdir != $output"
         ts_log_fine "started qrsh -l h=$host -wd $wdir pwd"
         ts_log_severe $error_text
      }

      # Test2 -cwd
      set output [start_sge_bin "qrsh" "-l h=$host -cwd pwd" "" "" exit_state 5 $cwdir]
      set output [replace_automount_prefix $output]
      if {![qrsh_output_contains $output $cwdir]} {
         set error_text "qrsh did not set the correct working dir: $cwdir != $output"
         ts_log_fine "started qrsh -l h=$host -cwd pwd  in directory $cwdir"
         ts_log_severe $error_text
      }

      # Test3 -cwd -wd $wdir
      set output [start_sge_bin "qrsh" "-l h=$host -cwd -wd $wdir pwd" "" "" exit_state 5 $cwdir]
      set output [replace_automount_prefix $output]
      if {![qrsh_output_contains $output $wdir]} {
         set error_text "qrsh did not set the correct working dir: $wdir != $output"
         ts_log_fine "started qrsh -l h=$host -cwd -wd $wdir pwd  in directory $cwdir"
         ts_log_severe $error_text
      }

      # Test4 -wd $wdir -cwd
      set output [start_sge_bin "qrsh" "-l h=$host -wd $wdir -cwd pwd" "" "" exit_state 5 $cwdir]
      set output [replace_automount_prefix $output]
      if {![qrsh_output_contains $output $cwdir]} {
         set error_text "qrsh did not set the correct working dir: $cwdir != $output"
         ts_log_fine "started qrsh -l h=$host -wd $wdir -cwd pwd  in directory $cwdir"
         ts_log_severe $error_text
      }
   }

   delete_all_jobs
   wait_for_end_of_all_jobs
}

#****** qrsh/qrsh_w_v_test() ******
#
#  NAME
#     qrsh_w_v_test
#
#  SYNOPSIS
#     qrsh_w_v_test { }
#
#  FUNCTION
#     Tests if qrsh -w v verifies and sends user notification about job verification
#
#  SEE ALSO
#
#*******************************
proc qrsh_w_v_test {} {
   global ts_config CHECK_USER
   global qrsh_hostlist qrsh_submithost

   ts_log_fine "qrsh -w v verification test"
   set arch [resolve_arch $qrsh_submithost]

   #submit qrsh -w v hostname job
   set qrsh_id [open_remote_spawn_process $qrsh_submithost $CHECK_USER $ts_config(product_root)/bin/$arch/qrsh "-w v hostname"]
   set sp_id [lindex $qrsh_id 1]
   set exitStatus 1
   #check for correct user notification
   set Job_Verify [translate_macro MSG_JOB_VERIFYFOUNDQ]
   set timeout 60
   expect {
      -i $sp_id full_buffer {
         ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
      }
      -i $sp_id "$Job_Verify" {
         ts_log_fine "qrsh successfully verified"
         exp_continue
      }
      -i $sp_id "_exit_status_:(*)*\n" {
         set exitStatus [string index [string trimleft $expect_out(buffer)] 15]
      }
      -i $sp_id default {
         ts_log_severe "qrsh to host $host failed"
      }
   }

   close_spawn_process $qrsh_id

   #if the exit status of qrsh is anyting but 0 an error occurred
   if { $exitStatus != 0 } {
      ts_log_severe "Expected return value of 0 was not found. Return value was $prg_exit_state"
   }

   wait_for_end_of_all_jobs
}

#****** qrsh/qrsh_pty_yes_line_breaks() ***
#
#  NAME
#     qrsh_pty_yes_line_breaks
#
#  SYNOPSIS
#     proc qrsh_pty_yes_line_breaks { }
#
#  FUNCTION
#     Tests if "qrsh -pty yes cat testfile.txt > out.txt" retains the line
#     breaks from testfile, i.e. doesn't change UNIX style line breaks
#     (NL) to DOS style line breaks (CR NL), or vice versa.
#     There are two files in the test directory, one with UNIX line
#     breaks, one wih DOS line breaks, both are printed by qrsh
#     and the output is compared to the original files.
#
#     This test tests the fix for GE-3382
#
#*******************************
proc qrsh_pty_yes_line_breaks {} {
   global CHECK_USER CHECK_ACTUAL_TEST_PATH
   global ts_config qrsh_hostlist

   set in_file_UNIX  $CHECK_ACTUAL_TEST_PATH/"UNIX_line_breaks.txt"
   set in_file_DOS   $CHECK_ACTUAL_TEST_PATH/"DOS_line_breaks.txt"
   set out_file_UNIX [get_tmp_file_name]
   set out_file_DOS  [get_tmp_file_name]

   # In runlevel 0, $qrsh_hostlist contains only one host, in higher runlevels more hosts
   foreach submit_host $qrsh_hostlist {
      foreach host $qrsh_hostlist {
         set arch [resolve_arch $submit_host]

         # Start "qrsh -pty yes UNIX_line_breaks.txt > UNIX_out"
         ts_log_fine "executing $ts_config(product_root)/bin/$arch/qrsh -l h=$host -pty yes \
            cat $in_file_UNIX > $out_file_UNIX on host $submit_host as $CHECK_USER"
         start_remote_prog $submit_host "$CHECK_USER" "$ts_config(product_root)/bin/$arch/qrsh" \
            "-l h=$host -pty yes cat $in_file_UNIX > $out_file_UNIX"

         # Start "qrsh -pty yes DOS_line_breaks.txt > DOS_out"
         ts_log_fine "executing $ts_config(product_root)/bin/$arch/qrsh -l h=$host -pty yes \
            cat $in_file_DOS > $out_file_DOS on host $submit_host as $CHECK_USER"
         start_remote_prog $submit_host "$CHECK_USER" "$ts_config(product_root)/bin/$arch/qrsh" \
            "-l h=$host -pty yes cat $in_file_DOS > $out_file_DOS"

         wait_for_end_of_all_jobs

         # Read files
         set in_file_UNIX_content  [start_remote_prog $submit_host "$CHECK_USER" \
                                    "cat" "$in_file_UNIX"]
         set out_file_UNIX_content [start_remote_prog $submit_host "$CHECK_USER" \
                                    "cat" "$out_file_UNIX"]
         set in_file_DOS_content   [start_remote_prog $submit_host "$CHECK_USER" \
                                    "cat" "$in_file_DOS"]
         set out_file_DOS_content  [start_remote_prog $submit_host "$CHECK_USER" \
                                    "cat" "$out_file_DOS"]

         # Compare files
         set UNIX_files_differ 0
         if {[string first "UNIX" $out_file_UNIX_content] == -1} {
            # the word "UNIX" from the original file is missing, the out file is corrupted
            set UNIX_files_differ 1
         } else {
            set diff_UNIX [start_remote_prog $submit_host "$CHECK_USER" "diff" \
                           "$in_file_UNIX $out_file_UNIX"]
            if {[string length $diff_UNIX] != 0} {
               # the key word exists, but the files differ - probably line breaks were changed
               set UNIX_files_differ 2
            }
         }

         set DOS_files_differ 0
         if {[string first "DOS" $out_file_DOS_content] == -1} {
            # the word "DOS" from the original file is missing, the out file is corrupted
            set DOS_files_differ 1
         } else {
            set diff_DOS [start_remote_prog $submit_host "$CHECK_USER" "diff" \
                          "$in_file_DOS $out_file_DOS"]
            if {[string length $diff_DOS] != 0} {
               # the key word exists, but the files differ - probably line breaks were changed
               set DOS_files_differ 2
            }
         }

         # report errors
         set error_string ""
         if {$UNIX_files_differ == 1} {
            set error_string "The UNIX out file seems to be corrupted. \
                              The qrsh command must have failed!"
         } elseif {$UNIX_files_differ == 2} {
            set error_string "UNIX in and out files differ! Probably line breaks were not preserved!"
         }
         if {$DOS_files_differ == 1} {
            set error_string "$error_string\nThe DOS out file seems to be corrupted. \
                                             The qrsh command must have failed!"
         } elseif {$DOS_files_differ == 2} {
            set error_string "$error_string\nDOS in and out files differ!\
                              Probably line breaks were not preserved!"
         }
         if {$UNIX_files_differ > 0 || $DOS_files_differ > 0} {
            ts_log_severe $error_string
            return
         } else {
            ts_log_fine "All line breaks were preserved! Excellent!"
         }
      }
   }
}

#****** qrsh/qrsh_pty_yes_redirect() ******
#
#  NAME
#     qrsh_pty_yes_redirect
#
#  SYNOPSIS
#     proc qrsh_pty_yes_redirect { }
#
#  FUNCTION
#     Tests if "qrsh -pty yes > out.txt" works properly.
#     To do this, this test starts a "qrsh -verbose -pty yes > $tmpfile",
#     checks the verbose output, checks if the job runs, enters "exit" in
#     the qrsh client, checks if the job ends properly and then checks
#     if there is output in the $tmpfile.
#     In runlevel long, this is done for hosts of all different architectures
#     in the test cluster, from all architectures to all architectures.
#
#     This test tests the fix for Issue 3025, 3031 and a part of 2735.
#
#  SEE ALSO
#
#*******************************
proc qrsh_pty_yes_redirect {} {
   global ts_config CHECK_USER
   global qrsh_hostlist

   foreach submit_host $qrsh_hostlist {
      foreach host $qrsh_hostlist {
         set arch [resolve_arch $submit_host]
         set tmpfile [get_tmp_file_name $submit_host]

         # Start "qrsh -pty yes > $tmpfile"
         ts_log_fine "executing $ts_config(product_root)/bin/$arch/qrsh -verbose\
                      -l h=$host -pty yes > $tmpfile on host $submit_host as $CHECK_USER"
         set qrsh_id [open_remote_spawn_process $submit_host $CHECK_USER \
                      $ts_config(product_root)/bin/$arch/qrsh "-verbose -l h=$host -pty yes > $tmpfile"]
         set sp_id [lindex $qrsh_id 1]

         # Scan the verbose output of qrsh for job id and check if an error message was print
         ts_log_fine "waiting for qrsh -pty yes to be scheduled"
         set job_id 0
         set remote_host ""

         set HAS_BEEN_SCHEDULED [translate_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_S "*"]
         set ESTABLISHING_SESSION [translate_macro MSG_QSH_ESTABLISHINGREMOTESESSIONTO_SS "*" "*"]
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               ts_log_severe "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               close_spawn_process $qrsh_id
               return
            }
            -i $sp_id timeout {
               # If qrsh prints no error message, we get this timeout, but $job_id
               # is != 0 then.
               if {$job_id == 0} {
                  # if $job_id is still 0, there was an error
                  ts_log_severe "timeout waiting for qrsh -pty yes to be submitted"
                  close_spawn_process $qrsh_id
                  return
               }
            }
            -i $sp_id eof {
               ts_log_severe "eof waiting for qrsh -pty yes to be submitted"
               close_spawn_process $qrsh_id
               return
            }
            -i $sp_id $HAS_BEEN_SCHEDULED {
               set job_id [lindex $expect_out(0,string) 3]
               # After this we expect the "Establishing session..." message
               exp_continue
            }
            -i $sp_id $ESTABLISHING_SESSION {
               set remote_host [lindex $expect_out(0,string) 5]
               # After this we expect either a error message or the login message
               exp_continue
            }
            -i $sp_id "*Error*" {
               # The command works not properly, likely it's the
               # "stdout is redirected" error.
               ts_log_severe "qrsh printed an error: $expect_out(0,string)"
               close_spawn_process $qrsh_id
               return
            }
            -i $sp_id "?*\n" {
               # If $job_id and $remote_host is set, this line
               # is either an error message (which is already caugh
               # by the block above, so we don't get here) or the first
               # lines of a login message (which we should catch here).
               # We can stop parsing then.
               # If $job_id or $remote_host is not yet set, the next
               # line is just an intermediate message we can skip and
               # continue parsing.
               if {$job_id == 0 || $remote_host == "" } {
                  exp_continue
               }
            }
         }
         if {$job_id != 0 && $remote_host != ""} {
            ts_log_fine "qrsh job $job_id correctly scheduled to remote host $remote_host"
         } else {
            ts_log_severe "qrsh job wasn't submitted"
            close_spawn_process $qrsh_id
            return
         }

         # Wait until job runs
         ts_log_fine "waiting until the job runs"
         if {[wait_for_jobstart $job_id "QRLOGIN" 60] != 0} {
            ts_log_severe "job $job_id does not start"
            close_spawn_process $qrsh_id
            delete_all_jobs
            return
         }

         # Write "exit" to the qrsh
         ts_log_fine "sending \"exit\" to the qrsh"
         ts_send $sp_id "exit\n"
         close_spawn_process $qrsh_id

         # Wait until job ends
         ts_log_fine "waiting until the job ends"
         wait_for_jobend $job_id "QRLOGIN" 60 0 0

         # Check if tmp.txt contains some login message
         get_file_content $submit_host $CHECK_USER $tmpfile file_content
         ts_log_finer "there are $file_content(0) lines in $tmpfile"
         for {set i 1} {$i<=$file_content(0)} {incr i} {
            ts_log_finer "line $i: $file_content($i)"
         }
         if {$file_content(0) == 0} {
            ts_log_severe "no output was redirected!"
            delete_all_jobs
            return
         }
      }
   }
   wait_for_end_of_all_jobs 60 0
}

#****** qrsh/qrsh_forward_stdin () ******
#
#  NAME
#     qrsh_forward_stdin
#
#  SYNOPSIS
#     proc qrsh_forward_stdin { }
#
#  FUNCTION
#     Tests if "qrsh cat < out.txt" works properly.
#     To do this, this test starts a 
#     "qrsh cat < $SGE_ROOT/man/man1/qdel.1 > $tmpfile",
#     checks if qrsh ends automatically within 60 seconds and checks if the 
#     input- and output-files are identical.
#     In runlevel long, this is done for hosts of all different architectures
#     in the test cluster, from all architectures to all architectures.
#
#     This test tests the fix for Issue GE-3580.
#
#  SEE ALSO
#
#*******************************
proc qrsh_forward_stdin {} {
   global ts_config CHECK_USER
   global qrsh_hostlist

   foreach submit_host $qrsh_hostlist {
      foreach host $qrsh_hostlist {
         set arch [resolve_arch $submit_host]
         set tmpfile [get_tmp_file_name $submit_host]
         set inputfile "$ts_config(product_root)/util/arch"

         # Start "qrsh stdin.sh < input_file"
         # Job has to finish within 60 seconds (timeout of start_remote_prog) otherwise GE-3580 is still present.
         ts_log_fine "executing on $submit_host: $ts_config(product_root)/bin/$arch/qrsh \
                      -l h=$host cat < $inputfile > $tmpfile on host $submit_host as $CHECK_USER"
         # Unfortunatelly we cannot use submit_job as the qrsh support is broken.
         # created TS-414
         start_remote_prog $submit_host $CHECK_USER "qrsh" "-l h=$host cat < $inputfile > $tmpfile" exit_code

         if {$exit_code != 0} {
            ts_log_severe "qrsh job failed. Exit code: $exit_code"
            delete_all_jobs
            return
         }

         # Check if tmp-file is identical to the input-file
         start_remote_prog $submit_host $CHECK_USER "diff" "$tmpfile $inputfile" exit_code
         if {$exit_code != 0} {
            ts_log_severe "Output file differs form input file"
            delete_all_jobs
            return
         }
      }
   }
   wait_for_end_of_all_jobs 60
}
