#___INFO__MARK_BEGIN_NEW__
###########################################################################
#
#  Copyright 2025 HPC-Gridware GmbH
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
###########################################################################
#___INFO__MARK_END_NEW__

# define global variable in this namespace
global check_name
global check_category
global check_description
global check_needs
global check_functions
global check_root_access_needs
global check_need_running_system
global check_version_range

set check_root_access_needs "yes"
#set check_need_running_system "no"
set check_version_range "9.1.0"

# define test's name and run level descriptions
set check_name            "cert_lifetime"
set check_category        "SECURITY TLS VERIFIED"
set check_description(0)  "test certificate lifetime handling with TLS encryption"

# define test's dependencies
set check_needs           "init_core_system"

# setup and cleanup functions
set check_setup_function cert_lifetime_setup
set check_cleanup_function cert_lifetime_cleanup

# define test's procedure order
set check_functions {}
lappend check_functions "cert_lifetime_qrsh"
lappend check_functions "cert_renew_qmaster"
lappend check_functions "cert_renew_execd"
lappend check_functions "cert_start_offset"

# -------- local test procedures: initialization------------------------------

proc cert_lifetime_setup {} {
   get_current_cluster_config_array ts_config
   global cert_lifetime_host cert_lifetime_backup

   # requires product_feature "tls" to be enabled in the config
   if {![config_has_product_feature "tls"]} {
      ts_log_config "TLS not enabled - skipping test"
      return 99
   }

   # we test with one host
   set cert_lifetime_host [host_conf_get_suited_hosts]

   # we will modify the bootstrap file - make a backup
   bootstrap_file_read cert_lifetime_backup
}

proc cert_lifetime_cleanup {} {
   get_current_cluster_config_array ts_config
   global cert_lifetime_host cert_lifetime_backup

   delete_all_jobs
   wait_for_end_of_all_jobs

   # restore the bootstrap file
   bootstrap_file_write cert_lifetime_backup 1

   # restart the cluster to make sure all components use the restored bootstrap file
   shutdown_core_system
   startup_core_system

   unset -nocomplain cert_lifetime_host cert_lifetime_backup
}

proc cert_lifetime_check_certificate {hostname cert_path expected_lifetime {not_before 0} {not_after 0} {predate 10}} {
   set ok [get_cert_info $hostname $cert_path cert_info]

   # we predate the begin time by 10 seconds to avoid clock issues - add that to the expected lifetime
   incr expected_lifetime $predate

   set errors {}

   if {$ok} {
      ts_log_fine "certificate is valid from $cert_info(not_before) ($cert_info(not_before_epoch)) to $cert_info(not_after) ($cert_info(not_after_epoch)), lifetime $cert_info(lifetime) seconds"
      if {$cert_info(lifetime) != $expected_lifetime} {
         set msg "expected certificate lifetime to be $expected_lifetime, got $cert_info(lifetime)"
         append msg "\nNot Before: $cert_info(not_before) ($cert_info(not_before_epoch))"
         append msg "\nNot After:  $cert_info(not_after) ($cert_info(not_after_epoch))"
         lappend errors $msg
         set ok 0
      }
      if {$not_before != 0} {
         if {$cert_info(not_before_epoch) < $not_before} {
            set msg "expected certificate not_before time to be >= $not_before, got $cert_info(not_before) ($cert_info(not_before_epoch))"
            lappend errors $msg
            set ok 0
         }
      }
      if {$not_after != 0} {
         if {$cert_info(not_before_epoch) > $not_after} {
            set msg "expected certificate not_before time to be <= $not_after, got $cert_info(not_before) ($cert_info(not_before_epoch))"
            lappend errors $msg
            set ok 0
         }
      }
   }

   if {[llength $errors] > 0} {
      ts_log_severe [join $errors "\n"]
   }

   return $ok
}

proc cert_lifetime_qrsh_and_check {hostname cert_path expected_lifetime {not_before 0}} {
   set ok 1

   # call qrsh
   set output [start_sge_bin "qrsh" "hostname"]
   if {$prg_exit_state != 0} {
      ts_log_severe "qrsh hostname failed:\n$output"
      set ok 0
   } else {
      ts_log_fine $output
   }

   # expect cerfificate and key to have been generated with the default lifetime (1 year)
   if {$ok} {
      set ok [cert_lifetime_check_certificate $hostname $cert_path $expected_lifetime $not_before]
   }

   return $ok
}

proc cert_lifetime_qrsh {} {
   get_current_cluster_config_array ts_config
   global CHECK_USER
   global cert_lifetime_host

   if {1} {
      # skip test as we currently do not cache client / qrsh certificates
      return
   }

   set ok 1

   # get paths for certificate and key
   set cert_path [get_tls_cert_path $cert_lifetime_host "qrsh" $CHECK_USER]
   set key_path [get_tls_key_path $cert_lifetime_host "qrsh" $CHECK_USER]
   set default_lifetime [get_tls_default_lifetime]

   # remove certificate and key
   delete_remote_file $cert_lifetime_host $CHECK_USER $cert_path
   delete_remote_file $cert_lifetime_host $CHECK_USER $key_path

   # call qrsh
   # expect certificate and key to have been generated with the default lifetime
   if {$ok} {
      set ok [cert_lifetime_qrsh_and_check $cert_lifetime_host $cert_path $default_lifetime]
   }

   # remove certificate and key, set earliest start time for the new certificate (with some 20 seconds leeway)
   if {$ok} {
      delete_remote_file $cert_lifetime_host $CHECK_USER $cert_path
      delete_remote_file $cert_lifetime_host $CHECK_USER $key_path
      set not_before [expr [clock seconds] - 20]
   }

   # set a short lifetime (e.g. the minimum, 2 minutes)
   if {$ok} {
      set lifetime 120
      set bs(security_params) "certificate_lifetime=$lifetime"
      bootstrap_file_write bs
   }

   # call qrsh
   # expect certificate and key to have been generated with the short lifetime
   if {$ok} {
      set ok [cert_lifetime_qrsh_and_check $cert_lifetime_host $cert_path $lifetime $not_before]
   }

   # wait until the certificate is expired
   if {$ok} {
      sleep_for_seconds 100 "waiting until certificate is about to expire..."
      # expect to get a new certificate with later not_before time
      set not_before [expr [clock seconds] - 20]
   }

   # call qrsh
   # expect certificate and key to have been regenerated with the short lifetime
   if {$ok} {
      set ok [cert_lifetime_qrsh_and_check $cert_lifetime_host $cert_path $lifetime $not_before]
   }

   # remove certificate and key
   if {$ok} {
      delete_remote_file $cert_lifetime_host $CHECK_USER $cert_path
      delete_remote_file $cert_lifetime_host $CHECK_USER $key_path
      set not_before [expr [clock seconds] - 20]
   }

   # remove the short lifetime setting
   if {$ok} {
      set bs(security_params) ""
      bootstrap_file_write bs
   }

   # call qrsh
   # expect certificate and key to have been generated with the default lifetime (1 year)
   if {$ok} {
      set ok [cert_lifetime_qrsh_and_check $cert_lifetime_host $cert_path $default_lifetime $not_before]
   }
}

proc cert_renew_qmaster {} {
   get_current_cluster_config_array ts_config
   global CHECK_USER

   set ok 1

   # get paths for certificate and key
   set cert_path [get_tls_cert_path $ts_config(master_host) "qmaster"]
   set key_path [get_tls_key_path $ts_config(master_host) "qmaster"]
   set default_lifetime [get_tls_default_lifetime]

   if {$ok} {
      ts_log_fine "TEST 1: check if certificates have been generated with the default lifetime"
      # shutdown qmaster
      shutdown_qmaster

      # remove certificate and key
      delete_remote_file $ts_config(master_host) $CHECK_USER $cert_path
      delete_remote_file $ts_config(master_host) "root" $key_path

      # start_qmaster and expect certificates to have default lifetime
      startup_qmaster
      set ok [cert_lifetime_check_certificate $ts_config(master_host) $cert_path $default_lifetime]

      # test clients using the new certificate
      if {$ok} {
         set output [start_sge_bin "qstat" "-f"]
         if {$prg_exit_state != 0} {
            ts_log_severe "qstat -f failed:\n$output"
            set ok 0
         }
      }

      # wait for execds to reconnect
      if {$ok && [wait_for_load_from_all_queues] < 0} {
         set ok 0
      }
   }

   if {$ok} {
      ts_log_fine "TEST 2: check if certificates are generated with a short lifetime"
      # shutdown qmaster
      set qmaster_shutdown_time [clock seconds]
      shutdown_qmaster

      # delete certificates
      delete_remote_file $ts_config(master_host) $CHECK_USER $cert_path
      delete_remote_file $ts_config(master_host) "root" $key_path

      # set short lifetime in bootstrap file
      set lifetime 120
      set bs(security_params) "certificate_lifetime=$lifetime"
      bootstrap_file_write bs

      # start qmaster and expect execds to reconnect to the qmaster using a new certificate
      startup_qmaster
      set qmaster_start_time [clock seconds]

      # check for the short lifetime
      set not_before [expr $qmaster_shutdown_time - 10]
      set ok [cert_lifetime_check_certificate $ts_config(master_host) $cert_path $lifetime $not_before]

      # test clients reconnecting with a new certificate
      if {$ok} {
         set output [start_sge_bin "qstat" "-f"]
         if {$prg_exit_state != 0} {
            ts_log_severe "qstat -f failed:\n$output"
            set ok 0
         }
      }

      # wait for execds to reconnect
      if {$ok && [wait_for_load_from_all_queues] < 0} {
         set ok 0
      }
   }

   if {$ok} {
      ts_log_fine "TEST 3: check if certificates are renewed after expiration"
      # wait for certificate to have expired and been renewed
      set wait_time [expr 120 - ([clock seconds] - $qmaster_start_time)]
      sleep_for_seconds $wait_time "waiting $wait_time seconds until certificate is about to expire..."

      # check lifetime of the new certificate - and later than the previous one
      set not_before [expr $qmaster_start_time + 60 - 10]
      set ok [cert_lifetime_check_certificate $ts_config(master_host) $cert_path $lifetime $not_before]

      # test clients reconnecting with a new certificate
      if {$ok} {
         set output [start_sge_bin "qstat" "-f"]
         if {$prg_exit_state != 0} {
            ts_log_severe "qstat -f failed:\n$output"
            set ok 0
         }
      }

      # execds must still be connected
      if {$ok && [wait_for_load_from_all_queues] < 0} {
         set ok 0
      }
   }

   if {$ok} {
      ts_log_fine "TEST 4: check if certificates are generated with the default lifetime after removing the short lifetime setting"
      # shutdown qmaster
      set qmaster_shutdown_time [clock seconds]
      shutdown_qmaster

      # delete certificates
      delete_remote_file $ts_config(master_host) $CHECK_USER $cert_path
      delete_remote_file $ts_config(master_host) "root" $key_path

      # remove short lifetime in bootstrap file
      set bs(security_params) ""
      bootstrap_file_write bs

      # start qmaster and expect execds to reconnect to the qmaster using a new certificate
      startup_qmaster

      # check for the default lifetime
      set not_before [expr $qmaster_shutdown_time - 10]
      set ok [cert_lifetime_check_certificate $ts_config(master_host) $cert_path $default_lifetime $not_before]

      # check clients reconnecting with a new certificate
      if {$ok} {
         set output [start_sge_bin "qstat" "-f"]
         if {$prg_exit_state != 0} {
            ts_log_severe "qstat -f failed:\n$output"
            set ok 0
         }
      }

      # wait for execds to reconnect
      if {$ok && [wait_for_load_from_all_queues] < 0} {
         set ok 0
      }
   }
}

proc cert_renew_check_execd_connection {execd_host} {
   get_current_cluster_config_array ts_config
   global CHECK_USER

   set ret 1

   set execd_port [expr $ts_config(commd_port) + 1]
   set opts "-info $execd_host $execd_port execd 1"
   set output [start_sge_bin "qping" $opts]
   if {$prg_exit_state != 0} {
      ts_log_severe "qping $opts failed:\n$output"
      set ret 0
   } else {
      ts_log_fine $output
   }

   return $ret
}

proc cert_renew_execd {} {
   get_current_cluster_config_array ts_config
   global CHECK_USER

   set ok 1

   # select a test host
   set execd_host [host_conf_get_suited_hosts]
   ts_log_fine "testing on exec host $execd_host"

   # get paths for certificate and key
   set cert_path [get_tls_cert_path $execd_host "execd"]
   set key_path [get_tls_key_path $execd_host "execd"]
   set default_lifetime [get_tls_default_lifetime]

   if {$ok} {
      ts_log_fine "TEST 1: check if certificates have been generated with the default lifetime"
      # check default lifetime
      set ok [cert_lifetime_check_certificate $execd_host $cert_path $default_lifetime]

      if {$ok} {
         # test if we can connect to the execd commlib server
         set ok [cert_renew_check_execd_connection $execd_host]
      }
   }

   if {$ok} {
      ts_log_fine "TEST 2: check if certificates are generated with a short lifetime"
      # shutdown execd
      set shutdown_time [clock seconds]
      shutdown_execd $execd_host

      # delete certificates
      delete_remote_file $execd_host $CHECK_USER $cert_path
      delete_remote_file $execd_host "root" $key_path

      # set short lifetime in bootstrap file
      set lifetime 120
      set bs(security_params) "certificate_lifetime=$lifetime"
      bootstrap_file_write bs

      # start execd and expect it to reconnect to the qmaster
      set startup_time [clock seconds]
      startup_execd $execd_host

      # check lifetime
      set not_before [expr $shutdown_time - 10]
      set ok [cert_lifetime_check_certificate $execd_host $cert_path $lifetime $not_before]

      if {$ok} {
         # test if we can connect to the execd commlib server
         set ok [cert_renew_check_execd_connection $execd_host]
      }
   }

   if {$ok} {
      ts_log_fine "TEST 3: check if certificates are renewed after expiration"

      # wait for certificate to have expired and been renewed
      set wait_time [expr 120 - ([clock seconds] - $startup_time)]
      sleep_for_seconds $wait_time "waiting $wait_time seconds until certificate is about to expire..."

      # check lifetime of the new certificate - and later than the previous one
      set not_before [expr $startup_time + 60 - 10]
      set ok [cert_lifetime_check_certificate $execd_host $cert_path $lifetime $not_before]

      if {$ok} {
         # test if we can connect to the execd commlib server
         set ok [cert_renew_check_execd_connection $execd_host]
      }
   }

   # remove short lifetime in bootstrap file
   set bs(security_params) ""
   bootstrap_file_write bs

   if {$ok} {
      ts_log_fine "TEST 4: check if certificates are generated with the default lifetime after removing the short lifetime setting"
      # shutdown execd
      set shutdown_time [clock seconds]
      shutdown_execd $execd_host

      # delete certificates
      delete_remote_file $execd_host $CHECK_USER $cert_path
      delete_remote_file $execd_host "root" $key_path

      # start execd
      startup_execd $execd_host

      # check for the default lifetime
      set not_before [expr $shutdown_time - 10]
      set ok [cert_lifetime_check_certificate $execd_host $cert_path $default_lifetime $not_before]
      if {$ok} {
         # test if we can connect to the execd commlib server
         set ok [cert_renew_check_execd_connection $execd_host]
      }
   }
}

proc cert_start_offset {} {
   global CHECK_USER

   # select a test host
   set execd_host [host_conf_get_suited_hosts]

   # get paths for certificate and key
   set cert_path [get_tls_cert_path $execd_host "execd"]
   set key_path [get_tls_key_path $execd_host "execd"]
   set default_lifetime [get_tls_default_lifetime]

   set ok 1
   if {$ok} {
      # shutdown the execd
      shutdown_execd $execd_host

      # delete certificates
      delete_remote_file $execd_host $CHECK_USER $cert_path
      delete_remote_file $execd_host "root" $key_path

      # set a high start_offset
      set bs(security_params) "certificate_start_offset=-300"
      bootstrap_file_write bs

      # start execd
      set start_time [clock seconds]
      startup_execd $execd_host

      # check the certificate times
      set not_before [expr $start_time - 310]
      set not_after [expr $start_time - 290]
      set ok [cert_lifetime_check_certificate $execd_host $cert_path $default_lifetime $not_before $not_after 300]
   }

   # reset to defaults, delete certificates, restart the execd
   set bs(security_params) ""
   bootstrap_file_write bs
   shutdown_execd $execd_host
   delete_remote_file $execd_host $CHECK_USER $cert_path
   delete_remote_file $execd_host "root" $key_path
   startup_execd $execd_host
}

