#___INFO__MARK_BEGIN_NEW__
###########################################################################
#
#  Copyright 2025 HPC-Gridware GmbH
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
###########################################################################
#___INFO__MARK_END_NEW__

# define global variable in this namespace
global check_name
global check_category
global check_description
global check_needs
global check_functions
global check_root_access_needs
global check_need_running_system
global check_version_range

#set check_root_access_needs "yes"
#set check_need_running_system "no"
set check_version_range {"9.0.9" "9.1.0"} ;# not yet merged into master branch

# define test's name and run level descriptions
set check_name            "consumable_dec"
set check_category        "CENTRY QALTER VERIFIED"
set check_description(0)  "test qalter -when now resources defined globally"
set check_description(1)  "test qalter -when now resources defined on an exec host"
set check_description(2)  "test qalter -when now resources defined in a queue instance"

# define test's dependencies
set check_needs           "init_core_system"

# setup and cleanup functions
set check_setup_function consumable_dec_setup
set check_setup_level_function consumable_dec_setup_level
set check_cleanup_level_function consumable_dec_cleanup_level
set check_cleanup_function consumable_dec_cleanup

# define test's procedure order
set check_functions {}
lappend check_functions "consumable_dec_sequential"
lappend check_functions "consumable_dec_array"
lappend check_functions "consumable_dec_parallel"

# -------- local test procedures: initialization------------------------------

proc consumable_dec_setup {} {
   get_current_cluster_config_array ts_config
   global consumable_dec_complex_backup

   # we create new complex variables
   get_complex consumable_dec_complex_backup
   set complex(test_int_y) "tiy INT <= YES YES 0 0"
   set complex(test_int_j) "tij INT <= YES JOB 0 0"
   set complex(test_int_h) "tih INT <= YES HOST 0 0"
   set complex(test_bool) "tb BOOL EXCL YES YES 0 0"
   set complex(test_double) "td DOUBLE <= YES YES 0 0"
   set complex(test_mem) "tm MEMORY <= YES YES 0 0"
   set_complex complex

   # add a pe and a test queue
   set pe(slots) 100
   set pe(allocation_rule) 2
   add_pe "test.pe" pe

   set q(pe_list) "test.pe"
   set q(slots) 10
   add_queue "test.q" "@allhosts" q
}

proc consumable_dec_setup_level {} {
   global consumable_dec_instance consumable_dec_backup consumable_dec_instance_type
   global CHECK_ACT_LEVEL

   set complex_values "test_int_y=10,test_int_j=10,test_int_h=10,test_bool=TRUE,test_double=10.0,test_mem=1024M"

   switch $CHECK_ACT_LEVEL {
      0 {
         # define complex capacity globally
         set consumable_dec_instance_type "global"
         set consumable_dec_instance "global"
         unset -nocomplain consumable_dec_backup
         get_exechost consumable_dec_backup
         replace_attr exechost "complex_values" $complex_values $consumable_dec_instance
      }
      1 {
         # define complex capacity on an exec host
         set consumable_dec_instance_type "exechost"
         set consumable_dec_instance [host_conf_get_suited_hosts 1]
         unset -nocomplain consumable_dec_backup
         get_exechost consumable_dec_backup $consumable_dec_instance
         replace_attr exechost "complex_values" $complex_values $consumable_dec_instance
      }
      2 {
         # define complex capacity in a queue instance
         set consumable_dec_instance_type "queue"
         set host [host_conf_get_suited_hosts 1]
         set consumable_dec_instance "test.q@${host}"
         get_queue $consumable_dec_instance consumable_dec_backup
         replace_attr queue "complex_values" $complex_values $consumable_dec_instance
      }
   }
}

proc consumable_dec_cleanup_level {} {
   global consumable_dec_instance consumable_dec_backup consumable_dec_instance_type
   global CHECK_ACT_LEVEL

   delete_all_jobs
   wait_for_end_of_all_jobs

   switch $CHECK_ACT_LEVEL {
      0 {
         replace_attr "exechost" "complex_values" $consumable_dec_backup(complex_values) $consumable_dec_instance
      }
      1 {
         replace_attr "exechost" "complex_values" $consumable_dec_backup(complex_values) $consumable_dec_instance
      }
      2 {
         replace_attr "queue" "complex_values" $consumable_dec_backup(complex_values) $consumable_dec_instance
      }
   }

   unset -nocomplain consumable_dec_instance consumable_dec_backup consumable_dec_instance_type
}

proc consumable_dec_cleanup {} {
   get_current_cluster_config_array ts_config
   global consumable_dec_complex_backup

   del_queue "test.q" "" 1 1
   del_pe "test.pe"

   reset_complex consumable_dec_complex_backup

   unset -nocomplain consumable_dec_complex_backup
}

proc consumable_dec_check_consumable {name expected_value situation} {
   get_current_cluster_config_array ts_config
   global consumable_dec_instance consumable_dec_instance_type

   switch $consumable_dec_instance_type {
      "global" {
         # use any queue instance
         set queue "test.q@[lindex $ts_config(execd_nodes) 0]"
         set level "gc"
      }
      "exechost" {
         # use queue instance on this exec host
         set queue "test.q@$consumable_dec_instance"
         set level "hc"
      }
      "queue" {
         # use the queue instance directly
         set queue $consumable_dec_instance
         set level "qc"
      }
   }

   qstat_F_plain_parse qstat_info $name "" "-q $queue"
   #parray qstat_info

   set expected_transformed [transform_unit $expected_value]
   set value_transformed [transform_unit $qstat_info($queue,$level:$name)]
   if {$value_transformed != $expected_transformed} {
      ts_log_severe "$situation: Consumable $name usage on $consumable_dec_instance_type $consumable_dec_instance is $qstat_info($queue,$level:$name), expected $expected_value"
      return 0
   } else {
      ts_log_fine "$situation: Consumable $name usage on $consumable_dec_instance_type $consumable_dec_instance is as expected: $expected_value"
   }

   return 1
}

proc consumable_dec_submit_check {job_opts name expected_empty submit_value expected_after_submit new_value expected_after_qalter expected_after_qdel} {
   get_current_cluster_config_array ts_config
   global consumable_dec_instance

   set ok 1
   # check consumable usage before submit
   if {![consumable_dec_check_consumable $name $expected_empty "before submit"]} {
      set ok 0
   }

   if {$ok} {
      # submit job
      set job_id [submit_job "$job_opts -q test.q -b y -l $name=$submit_value sleep 1000"]
      if {$job_id <= 0} {
         return
      }
      if {[wait_for_jobstart $job_id "" 10] != 0} {
         set ok 0
      }
   }

   if {$ok} {
      # verify that it consumes the resources
      if {![consumable_dec_check_consumable $name $expected_after_submit "after submit"]} {
         set ok 0
      }
   }

   if {$ok} {
      # then qalter -when now to decrease the resources
      if {$new_value == ""} {
         set opts "-l \"\""
      } else {
         set opts "-l $name=$new_value"
     }
      set output [start_sge_bin "qalter" "-when now $opts $job_id"]
      if {$prg_exit_state != 0} {
         ts_log_severe "qalter -when now $opts failed: $output"
         set ok 0
      } else {
         ts_log_fine "qalter -when now $opts succeeded: $output"
      }
   }

   if {$ok} {
      # verify that the resources are released
      if {![consumable_dec_check_consumable $name $expected_after_qalter "after qalter"]} {
         set ok 0
      }
   }

   # delete the job and wait until it is gone
   if {[delete_job $job_id 1] != 0} {
      set ok 0
   }

   if {$ok} {
      # verify that the resources are released
      if {![consumable_dec_check_consumable $name $expected_after_qdel "after qdel"]} {
         set ok 0
      }
   }
}

proc consumable_dec_sequential {} {
   get_current_cluster_config_array ts_config
   global consumable_dec_instance consumable_dec_backup

   # options of consumable_dec_submit_check:
   #   additional job_opts
   #   name of the consumable
   #   expected usage before submit
   #   submit value
   #   expected usage with job running
   #   new value for qalter
   #   expected usage after qalter
   #   expected usage after job deletion

   # typical license request
   consumable_dec_submit_check "" "test_int_y" 10 1 9 0 10 10

   # clearing all consumable requests
   consumable_dec_submit_check "" "test_int_y" 10 1 9 "" 10 10

   # different values
   consumable_dec_submit_check "" "test_int_y" 10 4 6 2 8 10

   # boolean
   consumable_dec_submit_check "" "test_bool" 1 1 0 0 1 1

   # double
   consumable_dec_submit_check "" "test_double" 10.0 2.5 7.5 1.0 9.0 10.0

   # memory
   consumable_dec_submit_check "" "test_mem" "1024M" "256M" "768M" "128M" "896M" "1024M"
}

proc consumable_dec_array {} {
   get_current_cluster_config_array ts_config
   global consumable_dec_instance consumable_dec_backup

   # options of consumable_dec_submit_check:
   #   additional job_opts
   #   name of the consumable
   #   expected usage before submit
   #   submit value
   #   expected usage with job running
   #   new value for qalter
   #   expected usage after qalter
   #   expected usage after job deletion

   # typical license request
   consumable_dec_submit_check "-t 1-5" "test_int_y" 10 1 5 0 10 10

   # clearing all consumable requests
   consumable_dec_submit_check "-t 1-10:2" "test_int_y" 10 1 5 "" 10 10

   # different values
   consumable_dec_submit_check "-t 1-3" "test_int_y" 10 3 1 2 4 10

   # boolean - it is exclusive, so only a single task will start up
   # same values as with sequential test
   consumable_dec_submit_check "-t 1-100:5" "test_bool" 1 1 0 0 1 1

   # double
   consumable_dec_submit_check "-t 1-4" "test_double" 10.0 2.5 0.0 1.0 6.0 10.0

   # memory
   consumable_dec_submit_check "-t 1-3" "test_mem" "1024M" "256M" "256M" "128M" "640M" "1024M"
}

proc consumable_dec_parallel {} {
   get_current_cluster_config_array ts_config
   global consumable_dec_instance consumable_dec_instance_type consumable_dec_backup

   # typical license request, per job consumable
   consumable_dec_submit_check "-pe test.pe 2" "test_int_j" 10 1 9 0 10 10

   # requesting an int with consumable YES
   consumable_dec_submit_check "-pe test.pe 2" "test_int_y" 10 1 8 0 10 10

   # requesting an int with consumable YES, arbitrary values
   consumable_dec_submit_check "-pe test.pe 2" "test_int_y" 10 3 4 1 8 10

   # boolean consumable
   # it shows a remaining capacity of -1
   # IMHO this is incorrect, submitted CS-1585 to fix it
   # consumable_dec_submit_check "-pe test.pe 2" "test_bool" 1 1 0 0 1 1

   # double consumable
   consumable_dec_submit_check "-pe test.pe 2" "test_double" 10.0 2.5 5.0 1.0 8.0 10.0

   # memory consumable
   consumable_dec_submit_check "-pe test.pe 2" "test_mem" "1024M" "256M" "512M" "128M" "768M" "1024M"

   # we test with parallel jobs, the pe has allocation rule "2"
   # with "global" consumables, the job can spawn multiple hosts, try to use 2 hosts
   # and do some additional testing
   if {$consumable_dec_instance_type eq "global" && [llength $ts_config(execd_nodes)] >= 2} {
      # int consumable
      consumable_dec_submit_check "-pe test.pe 4" "test_int_y" 10 2 2 1 6 10

      # host consumable
      consumable_dec_submit_check "-pe test.pe 4" "test_int_h" 10 2 8 1 9 10
   }
}
